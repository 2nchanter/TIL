### 📌 3.1 데이터와 자료형(Data and Data types)
- 정수 자료형 : `char`, `int`, `short`, `long` / unsigned, signed
- 실수 자료형 : `float`, `double`, `long double`


### 📌 3.2 변수와 상수(Variable and Constants)
- int angel = 1004;
  > int -> 자료형  
  > angel -> Variable(숫자를 담을 수 있는 메모리 공간)  
  > 1004 -> `literal constant(문자 그대로 불변의 값)`

- const int angel = 1004;
  > const -> Qualifier(한정자, 제한자)  
  > int -> 자료형  
  > angel = `Symbolic constant(기호적 상수)`  
  > 1004 -> literal constant


### 📌 3.3 scanf()
- &i는 i의 메모리 주소를 알려줍니다.  
  scanf는 해당 주소에 입력 값을 저장합니다.
  
- ⚠️ MSVC에서 보안 문제로 인해 경고를 발생시키는데, 경고를 무시하고 기존 C 표준 함수를 사용하고 싶다면, 매크로를 정의해야 함.  
  > a) #define _CRT_SECURE_NO_WARNINGS (macro)
  > b) project - properties - preprocessor - debug & release 모두 Definition에 _CRT_SECURE_NO_WARNINGS 입력

- GCC와 호환이 안됨 : GCC는 _CRT_SECURE_NO_WARNINGS와 같은 MSVC 전용 매크로를 인식하지 않습니다.
``` c
//#define _CRT_SECURE_NO_WARNINGS  // macro

#include <stdio.h>

int main()
{
    int i = 0;

    scanf("%d", &i);  // & : ampersand

    printf("Value is %d\n", i);

    return 0;
}
```


### 📌 3.4 간단한 입출력 프로그램 만들기
- https://alvinalexander.com/programming/printf-format-cheat-sheet/  
  ![Image](https://github.com/user-attachments/assets/2174bfbc-1d0b-4028-88da-39c6c5a11606)
- ⚠️ C 언어의 scanf는 포맷 문자열만 사용해야 하고, 공백 문자나 줄 바꿈 같은 건 넣으면 안 됩니다.
``` c
int main()
{
    float Won = 0.0f;
    float Dollar = 0.0f;

    printf("plz input Won\n");
    scanf("%f", &Won);

    Dollar = 0.00089f * Won;

    printf("Dollar = %f\n", Dollar);

    return 0;
}
```


### 📌 3.5 정수와 실수(Integers and Real numbers)
- C 언어에서는 변수 선언 시 메모리 공간을 자료형에 맞게 미리 확보합니다.  
  정수와 실수는 저장 방식과 연산 방식이 달라서 구분해야 합니다.
- Exponent : 3.14 = 3.14E0 = 3.14e0 = 0.314E1 = 31.4E-1
- signed와 unsigned는 range가 다름 (1bit을 부호에 할당하기 때문에)
- ⭐️ **부동소수점은 기본적으로 double에 할당 (정밀도 높음, 8바이트)**  
  메모리를 아끼기 위해 또는 정밀도가 덜 중요한 경우 float 사용 (4바이트)  
  float은 double의 절반 크기로 메모리 효율이 좋음
- float은 sign exponent mantissa ~~(fraction)~~ 으로 구성됨 (float은 unsigned가 없음)  
  > Fraction : 그냥 소수 부분을 가리킬 때 사용.  
  > Mantissa : 정규화된 유효숫자 부분. 부호 비트와 지수 부분을 제외한 나머지.
- 부동소수점 표준 방식 (https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/)  
  ![Image](https://github.com/user-attachments/assets/b88014e3-ad64-40eb-ae4f-8c650fca4286)


### 📌 3.6 정수의 오버플로우(Overflow)
- 2진수로 입력 / format specifier 문제 확인
``` c
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>

int main()
{
    //1
    unsigned int i = 0b11111111111111111111111111111111;  // 4byte -> 32bit
    unsigned int u = UINT_MAX;

    printf("%u\n", i);  // 4294967295
    printf("%u\n", u);  // 4294967295
    printf("%d\n", i);  // -1 -> signed int

    printf("%u\n", sizeof(unsigned int));
    printf("%u\n", sizeof(i));
}
```
- 0b : 뒤의 literal이 binary라는 의미. (C 표준은 아니다.)
- sizeof()는 연산자.  
  ⚠️ C4477: 'printf' : format string '%u' requires an argument of type 'unsigned int', but variadic argument 1 has type 'size_t'  
  consider using '%zu' in the format string
  > size_t는 C 언어에서 메모리 크기나 객체 크기를 다룰 때 사용되는 자료형  
  > %zu는 size_t 타입의 값을 출력하는 데 사용되며, %u는 unsigned int 타입의 값에 사용
  >   
  > size_t를 **unsigned int**로 형변환하여 사용할 수도 있지만, **%zu**로 서식 지정자를 변경하는 것이 더 안전하고 권장됩니다.  
  > size_t는 시스템 환경에 따른 차이점으로, 64비트 시스템에서 **unsigned long**이 될 수 있고, 32비트 시스템에서는 **unsigned int**일 수 있습니다.  
  > 이에 따라 %u로 size_t를 출력할 때 시스템 간 호환성 문제를 예방하기 위해 "%zu"를 사용하도록 유도합니다.  
  > 또한, C11 표준에서 size_t 타입을 출력할 때 **%zu**를 사용해야 한다고 명시하고 있기 때문에,  
  > VS2022는 이 표준을 따르기 위해 경고를 추가한 것으로 보입니다.

- %d여도 작은 숫자에서는 에러가 없었다.
``` c
    //2
    unsigned int i = 1024;

    printf("%d", i);  // 1024 -> OK

```

- Overflow 확인
``` c
    //3
    unsigned int u_max = UINT_MAX;  // macro
    unsigned int u_min = 0;
    signed int i_max = INT_MAX;
    signed int i_min = INT_MIN;

    printf("max of uint = %u\n", u_max);  // 4294967295
    printf("min of uint = %u\n", u_min);  // 0
    printf("max of int = %d\n", i_max);  // 2147483647
    printf("min of int = %d\n", i_min);  // -2147483648

    //4
    unsigned int u_max = UINT_MAX + 1;

    printf("%u\n", u_max);  // 0

    //5
    unsigned int u_max = UINT_MAX + 1;

    // i to binary representation
    char buffer[33];
    _itoa(u_max, buffer, 2);

    // print decimal and binary
    printf("decimal: %u\n", u_max);  // 0
    printf("binary: %s\n", buffer);  // 0

    //6
    signed int i_max = INT_MAX;
    signed int i_max1 = INT_MAX + 1;

    printf("int_max : %i\n", i_max);  // 2147483647
    printf("int_max + 1 : %i\n", i_max1);  //-2147483648
```
- ✅ UINT_MAX에서 F12(go to definition)로 직접 확인해보자. (UINT_MIN이 0이라 없고, INT_MAX, INT_MIN define 확인 가능.)
- char buffer[33];  
  문자를 33개 메모리에 나란히 저장할 수 있는 배열을 선언.  
  4byte * 8bit = 32bit인데 +1 해서 33을 사용하는 이유는??

- ⭐ **Overflow** : 32비트로 표현 가능한 최대값에 1을 더하면, 비트 수가 33개로 늘어나게 되지만 32비트 시스템에서는 이를 표현할 수 없으므로, 최상위 비트는 버려지고 값은 다시 0으로 돌아옵니다. 이 현상을 오버플로우라고 하며, 32비트 시스템에서는 더 이상 표현할 수 없는 값을 0으로 되돌리는 결과를 초래합니다.  
  > ex) if 4bit,  
  > 1111 + 1 = 1 0000  -->  UINT_MAX + 1 -> 0  
  > 1 0000 - 1         -->  0 -1         -> 4294967295


### 📌 3.7 다양한 정수형들
- 정수 자료형  
  ![Image](https://github.com/user-attachments/assets/fdef4cdc-d770-4c18-a2f4-02c44b2cbe7e)
- > hhd / hhu (c)  
  > hd / hu  
  > d or i / u  
  > ld / lu  
  > lld / llu
``` c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    char c = 65;
    short s = 200;
    unsigned int ui = 3000000000U;  // 3'000'000'000U  <-- c++ 표준
    long l = 65537L;
    long long ll = 12345678908642ll;  // 12'345'678'908'642ll

    // char는 %hhd로 출력하지만, %d(큰 자료형)로 출력해도 문제 없음.
    // %c는 문자열로 출력해준다.
    printf("char = %hhd, %d, %c\n", c, c, c);  // 65, 65, A
    // %hhd -> -128~128, 200 -> -56  ***Overflow***
    printf("short = %hhd, %hd, %d\n", s, s, s);  // -56, 200, 200
    // %d ***Overflow***
    printf("unsigned int = %u, %d\n", ui, ui);  // 3000000000, -1294967296
    // %hd ***Overflow***
    printf("long = %ld, %hd\n", l, l);  // 65537, 1
    // %ld ***Overflow***
    printf("long long = %lld, %ld\n", ll, ll);  // 12345678908642, 1942899938

    return 0;
}
```


### 📌 3.8 8진수와 16진수
- RGB color code는 16진수. ex) #33CC99
``` c
#include <stdio.h>

int main()
{
    // 4294967295
    unsigned int decimal = 4294967295;
    unsigned int binary = 0b11111111111111111111111111111111;  // 0b : 2진수
    unsigned int oct = 037777777777;  // 0 : 8진수
    unsigned int hex = 0Xffffffff;  // 0x : 16진수

    printf("%u\n", decimal);
    printf("%u\n", binary);
    printf("%u\n", oct);
    printf("%u\n", hex);

    // %o : 8진수, %x : 16진수
    // %#o : (prefix)8진수, %#x : (prefix)16진수, %#X : (PREFIX)16진수
    printf("%o %x %#o %#x %#X", decimal, decimal, decimal, decimal, decimal);

    return 0;
}
```


### 📌 3.9 고정 너비 정수


