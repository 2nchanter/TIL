### 📌 6.1 while 반복 루프에서 scanf()의 반환값 사용하기
- scanf()는 `성공적으로 변환된 항목의 개수를 반환`  
  while (scanf("%d", &num) == 1)  <<- C-style.  
``` c
#include <stdio.h>

int main()
{
	//int num, sum = 0, status;

	//printf("Enter an integer (q to quit) : ");
	//status = scanf("%d", &num);
	////printf("status : %d\n", status);

	//while (status == 1)  // equality operator
	//{
	//	sum += num;
	//	printf("sum = %d\n", sum);

	//	printf("Enter next integer (q to quit) : ");
	//	status = scanf("%d", &num);
	//	//printf("status : %d\n", status);
	//}

	//shortcut
	int num = 0, sum = 0;

	printf("Enter an integer (q to quit) : ");

	while (scanf("%d", &num) == 1)  // equality operator
	{
		sum += num;
		printf("Enter next integer (q to quit) : ");
	}
	printf("sum = %d\n", sum);

	return 0;
}
```


### 📌 6.2 의사 코드 Pseudo Code
- 프로그래밍 언어나 문법이 아니라 알고리즘에 집중하기 위해 작성.  
<img width="600" alt="image" src="https://github.com/user-attachments/assets/c8bada00-7e51-440a-9164-40ad3355e7fc" />  
<img width="400" alt="image" src="https://github.com/user-attachments/assets/34edf87f-ed32-4e53-8e5d-2b1f5c4bd6e5" />  


### 📌 6.3 진입조건 루프 while(Entry-Condition Loop)
- while() : 진입조건을 평가하고 만족시켰을 때 반복이 되는 블럭  
  indenting 개념.
``` c
#include <stdio.h>

int main()
{
	//while문 작성법
	//while (expression)  <- 0이면 중단, 0이 아니면 실행.
	//	statement         <- process


	int i;

	//i가 변하지 않아서 infinite loop (iteration, 반복)
	i = 1;
	while (i < 5)
		printf("Hi!\n");

	//wrong direction : --i라서
	i = 1;
	while(--i < 5)
		printf("Hi!\n");

	//cannot enter : i 초기값 문제
	i = 10;
	while (i++ < 5)
	{
		printf("Hi\n");
	}

	//correct!
	i = 1;
	while (i < 5)
	{
		printf("i before = %d\n", i);
		i++;
		printf("i after = %d\n", i);
	}


	//Common mistakes : indenting(들여쓰기 / c, c++에서는 블럭은 중괄호가 필요.)
	//반복문 내부에는 첫 번째 한 줄만 포함됨
	i = 0;
	while (i < 3)
		printf("%i\n", i);
		i++;

	//null statement
	i = 0;
	while (i++ < 3);  // semicolon error point
		printf("%i\n", i);

	//ok, but...
	while (scanf("%d", &i) == 1)
		;// null statement
	// do something (?)

	return 0;
}
```


### 📌 6.4 관계 연산자(Relational Operators)
- real number compare에서는 =!를 잘 쓰지 않는다.  
  fabs() : 절대값 반환 함수 (#include <math.h> 필요)
``` c
#include <stdio.h>
#include <math.h>	//fabs()

int main()
{
	//Relational Operators
	//<		is less than
	//<=		is less than or equal to
	//==		is equal to
	//>=		is greater than or equal to
	//>		is greater than
	//!=		is not equal to
	
	// n++ < 5 is a relational expression
	int n = 0;
	while (n++ < 5)
		printf("%d ", n);
	printf("\n");

	//not equal
	char c = 'A';
	while (c != 'Z')
		printf("%c ", c++);

	//real number compare에서는 =!를 잘 쓰지 않는다.
	const double PI = 3.1415926535897932384626433832795;
	double guess = 0.0;

	printf("Input PI : ");
	scanf("%lf", &guess);
	//while (guess != PI)
	while (fabs(guess - PI) > 0.001)  // 절대값 리턴 함수
	{
		printf("Fool! Try again.\n");
		scanf("%lf", &guess);
	}

	printf("Good!");

	return 0;
}
```


### 📌 6.5 사실과 거짓
- 0이면 false이고, 그 외에는 True이다.
``` c
#include <stdio.h>

int main()
{
	// expression은 값을 가진다.
	int tv, fv;
	tv = (1 < 2);
	fv = (1 > 2);

	//printf("True is %d\n", tv);  //True is 1
	//printf("False is %d\n", fv);  //False is 0

	// 0만 false이고, 양수 음수는 true이다.
	// = 0이면 false이고, 그 외에는 True이다.
	int i = 5;
	while (i)
		printf("%d is true\n", i--);
	printf("%d is false\n", i);

	// infinite loop : 계속 작동하는 것을 가정할 때
	while (1)
	{

	}

	return 0;
}
```


### 📌 6.6 _Bool 자료형
- C99에서 _Bool이 추가되었다. (_는 해당 자료형이 없는 코드들과의 호환성 유지 때문이다.)
- 












### 📌 6.7 
### 📌 6.8 
### 📌 6.9 
### 📌 6.10 









