### 📌 6.1 while 반복 루프에서 scanf()의 반환값 사용하기
- scanf()는 `성공적으로 변환된 항목의 개수를 반환`  
  while (scanf("%d", &num) == 1)  <<- C-style.  
``` c
#include <stdio.h>

int main()
{
	//int num, sum = 0, status;

	//printf("Enter an integer (q to quit) : ");
	//status = scanf("%d", &num);
	////printf("status : %d\n", status);

	//while (status == 1)  // equality operator
	//{
	//	sum += num;
	//	printf("sum = %d\n", sum);

	//	printf("Enter next integer (q to quit) : ");
	//	status = scanf("%d", &num);
	//	//printf("status : %d\n", status);
	//}

	//shortcut
	int num = 0, sum = 0;

	printf("Enter an integer (q to quit) : ");

	while (scanf("%d", &num) == 1)  // equality operator
	{
		sum += num;
		printf("Enter next integer (q to quit) : ");
	}
	printf("sum = %d\n", sum);

	return 0;
}
```


### 📌 6.2 의사 코드 Pseudo Code
- 프로그래밍 언어나 문법이 아니라 알고리즘에 집중하기 위해 작성.  
<img width="600" alt="image" src="https://github.com/user-attachments/assets/c8bada00-7e51-440a-9164-40ad3355e7fc" />  
<img width="400" alt="image" src="https://github.com/user-attachments/assets/34edf87f-ed32-4e53-8e5d-2b1f5c4bd6e5" />  


### 📌 6.3 진입조건 루프 while(Entry-Condition Loop)
- while() : 진입조건을 평가하고 만족시켰을 때 반복이 되는 블럭  
  `indenting` 개념.
``` c
#include <stdio.h>

int main()
{
	//while문 작성법
	//while (expression)  <- 0이면 중단, 0이 아니면 실행.
	//	statement         <- process


	int i;

	//i가 변하지 않아서 infinite loop (iteration, 반복)
	i = 1;
	while (i < 5)
		printf("Hi!\n");

	//wrong direction : --i라서
	i = 1;
	while(--i < 5)
		printf("Hi!\n");

	//cannot enter : i 초기값 문제
	i = 10;
	while (i++ < 5)
	{
		printf("Hi\n");
	}

	//correct!
	i = 1;
	while (i < 5)
	{
		printf("i before = %d\n", i);
		i++;
		printf("i after = %d\n", i);
	}


	//Common mistakes : indenting(들여쓰기 / c, c++에서는 블럭은 중괄호가 필요.)
	//반복문 내부에는 첫 번째 한 줄만 포함됨
	i = 0;
	while (i < 3)
		printf("%i\n", i);
		i++;

	//null statement
	i = 0;
	while (i++ < 3);  // semicolon error point
		printf("%i\n", i);

	//ok, but...
	while (scanf("%d", &i) == 1)
		;// null statement
	// do something (?)

	return 0;
}
```


### 📌 6.4 관계 연산자(Relational Operators)
- real number compare에서는 =!를 잘 쓰지 않는다.  
  `fabs()` : 절대값 반환 함수 (#include <math.h> 필요)
``` c
#include <stdio.h>
#include <math.h>	//fabs()

int main()
{
	//Relational Operators
	//<		is less than
	//<=		is less than or equal to
	//==		is equal to
	//>=		is greater than or equal to
	//>		is greater than
	//!=		is not equal to
	
	// n++ < 5 is a relational expression
	int n = 0;
	while (n++ < 5)
		printf("%d ", n);
	printf("\n");

	//not equal
	char c = 'A';
	while (c != 'Z')
		printf("%c ", c++);

	//real number compare에서는 =!를 잘 쓰지 않는다.
	const double PI = 3.1415926535897932384626433832795;
	double guess = 0.0;

	printf("Input PI : ");
	scanf("%lf", &guess);
	//while (guess != PI)
	while (fabs(guess - PI) > 0.001)  // 절대값 리턴 함수
	{
		printf("Fool! Try again.\n");
		scanf("%lf", &guess);
	}

	printf("Good!");

	return 0;
}
```


### 📌 6.5 사실과 거짓
- `0이면 false`이고, 그 외에는 True이다.
``` c
#include <stdio.h>

int main()
{
	// expression은 값을 가진다.
	int tv, fv;
	tv = (1 < 2);
	fv = (1 > 2);

	//printf("True is %d\n", tv);  //True is 1
	//printf("False is %d\n", fv);  //False is 0

	// 0만 false이고, 양수 음수는 true이다.
	// = 0이면 false이고, 그 외에는 True이다.
	int i = 5;
	while (i)
		printf("%d is true\n", i--);
	printf("%d is false\n", i);

	// infinite loop : 계속 작동하는 것을 가정할 때
	while (1)
	{

	}

	return 0;
}
```


### 📌 6.6 _Bool 자료형
- C99에서 _Bool이 추가되었다. (_는 해당 자료형이 없는 코드들과의 호환성 유지 때문이다.) (#include <stdbool.h>)
- `Conditional Operator`(삼항연산자) : (?:)  
  형식 : 변수 ? (True) : (False)
``` c
#include <stdio.h>
#include <stdbool.h>

int main()
{
	int i;
	i = 5;  // assignment operator
	i == 5;  // comparison operator
	5 = i;  // literal constant는 L-Value로 사용 불가.
	5 == i;

	// 보통 while 옆에는 comparison operator가 포함된 expression이 들어가는 것이 맞다.
	while (i = 5) {/*do something*/ };  (x)
	while (i == 5) {/*do something*/ };  (o)


	// _Bool도 내부적이로는 정수형으로 처리를 한다.
	_Bool boolean_true = (2 > 1);
	_Bool boolean_false = (1 > 2);

	printf("True is %d\n", boolean_true);
	printf("False is %d\n", boolean_false);

	// 조건 연산자
	printf(boolean_true ? "true" : "false");
	printf("\n");
	printf(boolean_false ? "true" : "false");

	// stdbool.h 안에 #define으로 대체되고 있다.
	bool bt = true;
	bool bf = false;

	printf("True is %d\n", bt);
	printf("False is %d\n", bf);

	return 0;
}
```


### 📌 6.7 관계 연산자의 우선순위
- Operators Precedence in C  
  <img width="300" alt="image" src="https://github.com/user-attachments/assets/124dabda-8546-4bdf-bca3-3f0c87e7daaa" />
``` c
#include <stdio.h>

int main()
{
	int x = 1, y = 2, z;

	x > y + 2;
	x > (y + 2);  // additive > relational

	x = y > 2;
	x = (y > 2);  // relational > assignment

	x != y == z;
	(x != y) == z;  // equality(same lv) is start at left.

	return 0;
}
```


### 📌 6.8 for 루프 소개
- Indefinite loop vs. Counting loop  
  while문 : Indefinite loop. 진입조건만 고려하기 때문. 하지만 Counting loop로 활용하는 경우가 많다.  
  for문 : Counting loop 작성에 효율.
  -> `Counter initialization; Counter check; Counter change` = for(initialize; test; update)
``` c
#include <stdio.h>

int main()
{
	//                     // Counting Loop
	//int i;

	//i = 1;               // 1. Counter initialization

	//while (i <= 10)	   // 2. Counter check
	//{
	//	printf("%d ", i);  // 3. Counter change
	//	i++;
	//}

	int i;

	for (i = 1; i <= 10; i++)  // Counter initialization; Counter check; Counter change
		printf("%d ", i);
	
	return 0;
}
```
<img width="450" alt="image" src="https://github.com/user-attachments/assets/bba99efe-1ffe-4fa0-9aed-e192ddc07913" />
<img width="500" alt="image" src="https://github.com/user-attachments/assets/2cac5159-d636-47ea-a140-69f1918537c9" />


### 📌 6.9 for는 유연해요
- prefix, postfix.
  `for문`은 초기화, 조건식, 증감식. 이 각각의 부분은 독립적인 실행 단위로,  
  조건식에 들어가는 i--나 --i는 이미 증감식이 실행된 후, 새로운 값이 조건식에 들어감.  
  이 부분은 `한 실행단위로 취급`되므로 조건을 비교할 때는 증감된 값이 사용됩니다.  
  `printf 함수`는 `단일 실행문`이기 때문에 후위 연산자(i--)는 출력 후 감소가 발생하고, 전위 연산자(--i)는 출력 전에 감소가 발생
  >>> 결론 : for문에서는 조건 비교에서 이미 증감된 값이 사용되고, printf에서는 출력 시점에서 차이가 발생.
``` c
#include <stdio.h>

int main()
{

	//for(initialize; test; update)
	//	statement


	for (int i = 5; i > 0; i--)
		printf("%d ", i);  // 5 4 3 2 1

	for (int i = 5; i > 0; --i)
		printf("%d ", i);  // 5 4 3 2 1

	for (int i = 0; i < 20; i = i + 8)
		printf("%d ", i);  // 0 8 16

	for (char c = 'A'; c <= 'Z'; c++)
		printf("%c ", c);  // A ~ Z

	for (int i = 0; i * i < 10; i++)
		printf("%d ",
	 i);  // 0 1 2 3

	// 같은 자료형은 다중 선언 가능.
	for (int x = 1, y = 5; y <= 20; y = (++x * 3) + 10)  // !!! Prefix, Postfix 확인 !!!
		printf("%d ", x);  // 1 2 3

	for (int x = 1, y = 5; y <= 20; y = (x++ * 3) + 10)
		printf("%d ", x);  // 1 2 3 4

	for (double d = 100.0; d < 300; d = d * 1.1)
		printf("%f\n", d);


	// blank
	int i, n;
	n = 2;
	for (i = 2; n < 10; /* left blank */)
	{
		n = n * i;
		printf("%d\n", n);  // 4 8 16
	}


	// infinite loop
	for (;;)  // while(1)
		printf("I love you! ");

	int i = 0;
	for(printf("Let's go!\n"); i != 7; scanf("%d", &i))
		;// null statement

	return 0;
}
```


### 📌 6.10 다양한 대입 연산자들 (그리고 어셈블리 코드 확인법)




















