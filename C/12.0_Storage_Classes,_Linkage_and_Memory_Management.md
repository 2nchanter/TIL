### ğŸ“Œ 12.1 ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ í›‘ì–´ë³´ê¸°
<img width="650" src="https://github.com/user-attachments/assets/c1e5a371-4e02-4e02-9139-ba7c58827498"/>

<img width="500" src="https://github.com/user-attachments/assets/7a7de061-7b3d-40ae-a377-f8ab98e59e1a"/>

- stack (ì§€ì—­ ë³€ìˆ˜) -> í¬ê¸° ë³€ë™  
  ë©”ëª¨ë¦¬ ì‚¬ì´ì¦ˆê°€ compile timeì— ê²°ì •ë¨  
  ì¤‘ê´„í˜¸ ì•ˆì—ì„œ ìë™ìœ¼ë¡œ ë©”ëª¨ë¦¬ì˜ í• ë‹¹ ë° (ìš´ì˜ì²´ì œì—ê²Œë¡œ) ë°˜ë‚©ì´ ì´ë£¨ì–´ ì§„ë‹¤.  
  Tip) í° ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•´ì•¼í•˜ëŠ” ê¸°ëŠ¥ì€, í•¨ìˆ˜ë¡œ ë¶„ë¦¬í•´ì„œ ì‚¬ìš© í›„ ë°˜ë‚©í•˜ëŠ” ê²ƒì´ íš¨ìœ¨ì ì´ë‹¤.  
- Free -> í¬ê¸° ë³€ë™  
- Heap -> í¬ê¸° ë³€ë™  
- ë©”ëª¨ë¦¬ ì‚¬ì´ì¦ˆê°€ compile timeì— ê²°ì •ë˜ì§€ ì•ŠìŒ  
  ë©”ëª¨ë¦¬ë¥¼ ë°°ì •í•  ë•Œ, ì–´ë””ì— ë°°ì •í•´ì•¼ ë ì§€ ìš´ì˜ì²´ì œë¥¼ ê±°ì³ì„œ ë©”ëª¨ë¦¬ì˜ í• ë‹¹ ë° ë°˜ë‚©ì´ ë˜ë¯€ë¡œ ëŠë¦¬ë‹¤.  
  ì‚¬ìš© ì¢…ë£Œ í›„ manualë¡œ free(arr)ì²˜ëŸ¼ ë°˜ë‚© í•„ìš”!  
- BSS(Block Started by Symbol) Segment (ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ ì „ì—­ ë³€ìˆ˜ë“¤) -> í¬ê¸° ê³ ì •  
  DATA Segment (ì´ˆê¸°í™”ëœ ì „ì—­ ë³€ìˆ˜ë“¤) -> í¬ê¸° ê³ ì •  
- Text Segment(í”„ë¡œê·¸ë¨ ì½”ë“œ, Read Only) -> í¬ê¸° ê³ ì •  
  ì‹¤í–‰ì„ ìœ„í•´ì—¬ í”„ë¡œê·¸ë¨ ìì²´ê°€ ë©”ëª¨ë¦¬ì— ì˜¬ë¼ê°€ëŠ” ì¥ì†Œ.


### ğŸ“Œ 12.2 ê°ì²´(Object)ì™€ ì‹ë³„ì(Identifier), lvalueì™€ rvalue
``` c
#include <stdio.h>

int main()
{
	/*
		Object (ê°ì²´)
		- "An object is simply a block of memory that can store a value." (KNK p. 487)
		 = ë©”ëª¨ë¦¬ ê³µê°„ì„ ê°–ê³  ìˆìœ¼ë©´ ê°ì²´ !
		- Object has more develped meaning in C++ and Object Oriented Programming (OOP)
		 = pythonì˜ ê°ì²´ëŠ” cì–¸ì–´ì˜ ê°ì²´ì—ì„œ í™•ì¥ëœ ê°œë…. oop(ê°ì²´ì§€í–¥ í”„ë¡œê·¸ë˜ë°)

		Identifiers (ì¸ì‹ì)
		- Names for variables, functions, macros, and other entities. (KNK p. 25)
		 = ë³€ìˆ˜ ì´ë¦„ !
	*/

	// ê°ì²´ëŠ” ë©”ëª¨ë¦¬ ê³µê°„, ì¸ì‹ìëŠ” var_name
	// ë©”ëª¨ë¦¬ ê³µê°„ì— 3ì´ë¼ëŠ” ê°’ì„ ë³µì‚¬í•´ì„œ ë„£ì–´ì£¼ëŠ” ê²ƒ.
	// ì¸ì‹ìëŠ” ì´ë¦„ì— ë¶ˆê³¼í•œë° ë§ˆì¹˜ ê°ì²´ë¥¼ ì§ì ‘ ë‹¤ë£¨ëŠ” ê²ƒ ì²˜ëŸ¼ cì–¸ì–´ê°€ ë„ì™€ì¤Œ.
	int var_name = 3;		// creates an object called 'var_name'.

	int* pt = &var_name;	// pt is an identifier.
	*pt = 1;				// *pt is not an identifier. *pt designates an object.

	int arr[100];	// arr is an identifier. Is arr an object?
	arr[0] = 7;		// arr[0] is an object.

	/*
		lvalue is an expression 'referring' to an object. (K&R p.197)

		L-value : left side of an assignment
		R-value : right side, variable, constant, expressions (KNK p. 67)
	*/

	var_name = 3;	// modifiable lvalue
	int temp = var_name;
	temp = 1 + 2;

	pt = &var_name;
	int* ptr = arr;
	*pt = 7;	// *pt is not an identifier but an modifiable lvalue expression.

	int* ptr2 = arr + 2 * var_name; // address rvalue
	*(arr + 2 * var_name) = 456;	// lvalue expression

	const char* str = "Constant string";		// str is a modifiable lvalue.
	str = "Second string";	// "Constant string" = "Second String"	// impossible
	//str[0] = 'A'; // Error
	//puts(str);

	char str2[] = "String in an array";
	str2[0] = 'A';	// OK
	//puts(str2);

	/*
		Identifiers have scope.
		Objects have storage duration.
		Variables and functions have one of the following linkages:
			external linkage, internal linkage, or no linkage.
	*/

	return 0;
}
```


### ğŸ“Œ 12.3 ë³€ìˆ˜ì˜ ì˜ì—­(Scope)ê³¼ ì—°ê²° ìƒíƒœ(Linkage), ê°ì²´ì˜ ì§€ì† ê¸°ê°„(Duration)
- BSS segmentì—ì„œ g_jê°€ 0ìœ¼ë¡œ ì´ˆê¸°í™” ë˜ê¸° ë•Œë¬¸ì—, ëª…ì‹œí•˜ì§€ ì•Šì•„ë„ printf("%d\n", g_j) ì—ì„œ ì—ëŸ¬ê°€ ì—†ë‹¤. (g_jëŠ” file scopeì´ë‹¤. = ì „ì—­ë³€ìˆ˜)  
- file 's scope.
``` c
#include <stdio.h>

/*
	ë³€ìˆ˜ì˜ ì˜ì—­
	Variable scopes (visibility)
	- block, function, function prototype, file.
*/

int g_i = 123;	// global variable
int g_j;		// global variable

void func1()
{
	g_i++; 	// uses g_i
}

void func2()
{
	g_i += 2;	// uses g_i

	//local = 456;	// Error
}

int main()
{
	int local = 1234;

	func1();
	func2();

	printf("%d\n", g_i);	// 126	// uses g_i
	printf("%d\n", g_j);	// 0    // Not initialized?  
	printf("%d\n", local);	// 1234

	return 0;
}
```
- block, function, function prototype 's scope.
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/*
	Variable scopes (visibility)
	- block, function, function prototype, file.
*/

void f1(int hello, double world);	// prototype declaration(ì§€ì†ê¸°ê°„)ì€ ì§€ê¸ˆ ì´ ë¬¸ì¥ ëë‚˜ëŠ” ì§€ì ê¹Œì§€.
//void vla_param(int n, int m, double ar[n][m]); // gcc only

double func_block(double d)
{
	double p = 0.0;

	int i;
	for (i = 0; i < 10; i++)
		//for (int i = 0; i < 10; i++) // C99
	{
		double q = d * i;
		p *= q;

		if (i == 5)
			goto hello;
	}

hello:
	printf("Hello, World");

	return p;
}

int main()
{
	func_block(1.0);
}

void f1(int hello, double world)
{
}

//void vla_param(int n, int m, double ar[n][m])
//{
//
//}
```
- (Linker <->) Linkage  
  compilter translation Unitì€ fileì´ë‹¤. fileì´ ë¶„ë¦¬ë˜ì–´ ìˆìœ¼ë©´ ì„œë¡œ ì•Œ ë°©ë²•ì´ ì—†ë‹¤.  
  `int main() ë°–ì— ì„ ì–¸í•œ ë³€ìˆ˜`ëŠ” `extern` (ì €ì¥ í´ë˜ìŠ¤ ì§€ì •ì(Storage Class Specifier))ì„ ì‚¬ìš©í•˜ì—¬ ë‹¤ë¥¸ fileì—ì„œë„ ì‚¬ìš©ì´ ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì—, í•´ë‹¹ ë³€ìˆ˜ ì´ë¦„ì´ `ì „ì—­ ë³€ìˆ˜`ê°€ ë˜ì—ˆë‹¤.  
  `static`ì„ ë¶™ì´ë©´, `í•´ë‹¹ íŒŒì¼ì—ì„œë§Œ ì ‘ê·¼ ê°€ëŠ¥`í•˜ë‹¤. (internal linkage)  
  <img width="500" src="https://github.com/user-attachments/assets/14dc0542-9d11-4e22-b38f-490261836600"/>

``` c
//////// 03B_Linkage
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/*
	Linkage

	Variables with block scope, function scope, or function prototype scope
	- No linkage

	File scope variables
	- External or internal linkage
*/

// translation unit

int el;			// file scope with external linkage (global variable)
static int il;	// file scope with internal linkage

void testLinkage();

int main()
{
	el = 1024;

	testLinkage();

	printf("%d\n", el);

	return 0;
}

//////// second.c
#include <stdio.h>

extern int el;
//extern int il;

void testLinkage()
{
	printf("DoSomething called\n");
	printf("%d\n", el);
	//printf("%d\n", il);
	//printf("%d", dodgers);

	el++;
}
```
- duration
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/*
	Storage duration:
	- static storage duration  <- ì‹œì‘í•  ë•Œë¶€í„° ëë‚  ë•Œê¹Œì§€ ìœ ì§€. (Text Segment)
	  (Note: 'static' keyword indicates the linkage type, not the storage duration) * ê°œë…ì°¨ì´!
	- automatic storage duration  <- ì§€ì—­ë³€ìˆ˜ (stack)
	- allocated storage duration  <- ë™ì í• ë‹¹ (heap)
	- thread storage duration  <- ë©€í‹°ì“°ë ˆë”©
*/

void count()
{
	int ct = 0;
	printf("count = %d\n", ct);
	ct++;
}

void static_count()
{
	static int ct = 0;  // í•¨ìˆ˜ê°€ ì¢…ë£Œë˜ì–´ë„ ë³€ìˆ˜ê°€ ìœ ì§€ëœë‹¤.
	printf("static count = %d\n", ct);
	ct++;
}

int main()
{
	count();  // count = 0
	count();  // count = 0
	static_count();  // static count = 0
	static_count();  // static count = 1

	return 0;
}
```


### ğŸ“Œ 12.4 ì €ì¥ ê³µê°„ì˜ ë‹¤ì„¯ ê°€ì§€ ë¶„ë¥˜(Five Storage Classes)
<img width="700" alt="image" src="https://github.com/user-attachments/assets/d1b61d5d-3809-4fb7-8a17-898b81c3555b" />


### ğŸ“Œ 12.5 ìë™ ë³€ìˆ˜(Automatic Variables)
``` c
#include <stdio.h>

/*
	Automatic storage class
	- Automatic storage duration, block scope, no linkage
	- Any variable declared in a block or function header
*/

void func(int k);

int main()	//Note: main() is a function.
{
	auto int a;	// keyword auto : a storage-class specifier
	a = 1024;
	//printf("%d\n", a);		// what happens if uninitialized?
	auto int b = a * 3;		// what happens if uninitialized?

	int i = 1;
	int j = 2;

	printf("i %lld\n", (long long)&i);  // i 18085644

	{
		int i = 3;	// name hiding  <- ì´ë¦„ì´ ê²¹ì³ì„œ ë¶€ë¥¼ ìˆ˜ ì—†ì–´ì„œ ì‚¬ìš©ì„ ëª»í•  ë¿.
		printf("i %lld\n", (long long)&i);  // i 18085620

		int ii = 123;
		// j is visible here
		printf("j = %d\n", j);  // j = 2
		// memoryì— stackë˜ì„œ ì•ˆìª½ blockì—ì„œ ë°–ì— blockì˜ jë¥¼ ì‚¬ìš©ê°€ëŠ¥í•˜ë‹¤. (ë°˜ëŒ€ë¡œëŠ” ë¶ˆê°€)
	}

	// ii is not visible here

	printf("i %lld\n", (long long)&i);	// i 18085644

	for (int m = 1; m < 2; m++)
		printf("m %lld\n", (long long)&m);  // m 18085596	// forë¬¸ ì•ˆì— scope.

	func(5);	// cannot see any of the variabled defined so far.

	for (int m = 3; m < 4; m++)
	{
		printf("m %lld\n", (long long)&m);  // m 18085584			// block?
	}

	return 0;
}

void func(int k)  // stack frame ìì²´ê°€ ë³€í•œë‹¤. (block scope -> finction scope)
{
	int i = k * 2;
	// do something with i and k
	printf("i %lld\n", (long long)&i);  // i 18085352
}
```


### ğŸ“Œ 12.6 ë ˆì§€ìŠ¤í„° ë³€ìˆ˜(register)
- cpuì˜ ì„ì‹œ ì‘ì—…ê³µê°„. (memoryëŠ” cpuì™€ ë¶„ë¦¬ë˜ì–´ ìˆìŒ.)  
  'register' keywordë¡œ ìš”ì²­ì€ ê°€ëŠ¥í•˜ì§€ë§Œ, ë§¤ë²ˆ registerì— ì˜¬ë¼ê°€ì§€ëŠ” ì•ŠëŠ”ë‹¤.  
  (ë§ì´ ì‚¬ìš©í•˜ì§€ëŠ” ì•ŠìŒ = GPU, ë³‘ë ¬ì²˜ë¦¬ ë“±ìœ¼ë¡œ ìš°íšŒ.)
``` c
#include <stdio.h>

void temp(register int r)
{
	// do something with r
}

int main()
{
	register int r;
	r = 123;

	//printf("%p\n", &r);
	//int* ptr = &r;  // registerì˜ ì£¼ì†ŒëŠ” ê°€ì§€ê³  ì˜¬ ìˆ˜ ì—†ìŒ.

	return 0;
}
```


### ğŸ“Œ 12.7 ë¸”ë¡ ì˜ì—­ì˜ ì •ì (static) ë³€ìˆ˜
``` c
#include <stdio.h>

void count()
{
	int ct = 0;  // ëë‚˜ë©´ stackì—ì„œ ë¹ ì ¸ë‚˜ê°. (=function scope)
	printf("count = %d %lld\n", ct, (long long)&ct);
	ct++;

	//return &ct;	// í¬ì¸í„°ë¥¼ ë°˜íší•´ë„, stackì—ì„œ ì‚¬ë¼ì§€ëŠ” ë©”ëª¨ë¦¬ì´ê¸° ë–„ë¬¸ì— ì˜ë¯¸ê°€ ì—†ë‹¤.
}

void static_count()
{
	// ì •ì  ë©”ëª¨ë¦¬ë‹ˆê¹Œ ì´ˆê¸°í™”ëŠ” í•œë²ˆë§Œ ëœë‹¤.
	static int ct = 0;	// (Data seg. or BSS seg.)
	printf("static count = %d %lld\n", ct, (long long)&ct);
	ct++;

	//return &ct;	// ê³ ì • ì£¼ì†Œë¼ ê°€ëŠ¥ì€ í•˜ì§€ë§Œ, ê¶Œì¥í•˜ì§€ëŠ” ì•ŠìŒ. (ì°¨ë¼ë¦¬ ì „ì—­ë³€ìˆ˜)
}

/*
	ë§¤ê°œë³€ìˆ˜ëŠ” í˜¸ì¶œë  ë•Œë§ˆë‹¤ ìƒˆë¡œìš´ ê°’ì´ ìŠ¤íƒì— ì €ì¥ë©ë‹ˆë‹¤.
	ê·¸ëŸ°ë° staticì„ ë¶™ì´ë©´, ë³€ìˆ˜ê°€ ìŠ¤íƒì´ ì•„ë‹ˆë¼ **ì •ì  ë©”ëª¨ë¦¬(BSS/DATA ì˜ì—­)**ì— ì €ì¥ë˜ë„ë¡ ê°•ì œí•˜ëŠ” ì…ˆì´ ë©ë‹ˆë‹¤.
	ì´ë ‡ê²Œ í•˜ë©´ í•¨ìˆ˜ í˜¸ì¶œ ë°©ì‹ê³¼ ë§ì§€ ì•Šê¸° ë•Œë¬¸ì— ë¬¸ë²•ì ìœ¼ë¡œ í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
*/
//int func(static int i)	// Warning (Error in GCC)
//{
//}

void counter_caller()
{
	count();
}

void static_counter_caller()
{
	static_count();
}

int main()
{
	count();  // ì§ì ‘í˜¸ì¶œ (ë¶ˆëŸ¬ì§€ëŠ” í•¨ìˆ˜ê°€ count()ë°–ì— ì—†ì–´ì„œ ì£¼ì†Œê°€ ê°™ì„ ìˆ˜ë„ ìˆë‹¤.
	count();
	counter_caller();  // ê·¸ë˜ì„œ ê°„ì ‘í˜¸ì¶œë¡œ ì£¼ì†Œ ë‹¤ë¥¸ ê²ƒ í™•ì¸.

	static_count();  // ì•„ë˜ 3ê°œëŠ” ëª¨ë‘ ì£¼ì†Œê°€ ê°™ë‹¤.
	static_count();
	static_counter_caller();

	return 0;
}
```


### ğŸ“Œ 12.8 ì •ì  ë³€ìˆ˜ì˜ ì™¸ë¶€ ì—°ê²° (static variables with external linkage)
- defining declaration vs referencing declaration  
  <img width="650" alt="image" src="https://github.com/user-attachments/assets/58a6d28a-8c4f-4d6d-96ab-00c3d40ad26c" />
  <img width="600" alt="image" src="https://github.com/user-attachments/assets/7aaba2a4-ed7d-4482-9a1a-257a6d97fb85" />

``` c
// main.c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/*
	Static variable with external linkage
	- File scope, external linkage, static storage duration
	- External storage class
	- External variables
*/

/*
	Initializing External Variables
*/
int x = 5;					// ok, constant expression
int y = 1 + 2;				// ok, constant expression
size_t z = sizeof(int);		// ok, sizeof is a constant expression
//int x2 = 2 * x;			// not ok, x is a variable

int g_int = 0;
double g_arr[1000] = { 0.0, };

void fun()
{
	printf("g_int in fun() %d %p\n", g_int, &g_int);
	g_int += 10;
}

extern void fun_sec();

int main()
{
	/*
		defining declaration vs referencing declaration
	*/

	extern int g_int;			// Optional
	//extern int g_int = 1024;	// Error in block scope

	//int g_int = 123;			// hides global g_int

	extern double g_arr[];		// optional, size is not necessary (ì‚¬ì´ì¦ˆëŠ” ìœ„ì—ì„œ ì´ë¯¸ ì •ì˜ë˜ì—ˆê¸° ë•Œë¬¸ì—)

	printf("g_int in main() %d %p\n", g_int, &g_int);
	g_int += 1;

	fun();
	fun_sec();

	return 0;
}

// second.c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>	// printf() in second.c

extern int g_int;

void temp()
{
	g_int += 1000;
}

void fun_sec()
{
	temp();

	extern int g_int;

	g_int += 7;
	printf("g_int in fun_sec() %d %p\n", g_int, &g_int);
}

```


### ğŸ“Œ 12.9 ì •ì  ë³€ìˆ˜ì˜ ë‚´ë¶€ ì—°ê²° internal linkage
- staticì„ ì „ì—­ë³€ìˆ˜ ì•ì— ë¶™ì´ê²Œ ë˜ë©´, íŒŒì¼ ë‚´ì—ì„œë§Œ ì‚¬ìš©ê°€ëŠ¥í•´ì§„ë‹¤.  
  ì „ì—­ ë³€ìˆ˜ì˜ ë²”ìœ„ë¥¼ ì œí•œí•˜ì—¬, ë¶ˆí•„ìš”í•œ ì™¸ë¶€ ì ‘ê·¼ì„ ë§‰ê³  ì¶©ëŒì„ ë°©ì§€í•˜ëŠ” ë° ìœ ìš©.  
  (static í‚¤ì›Œë“œëŠ” ë³€ìˆ˜ë‚˜ í•¨ìˆ˜ì˜ ìƒì¡´ ê¸°ê°„(lifetime)ê³¼ ê°€ì‹œ ë²”ìœ„(scope)ë¥¼ ì œì–´í•˜ëŠ” ì—­í• )

<img width="900" alt="image" src="https://github.com/user-attachments/assets/4b00b02f-e86a-4e92-9017-014c8da21da5" />


### ğŸ“Œ 12.10 ë³€ìˆ˜ì˜ ì €ì¥ ê³µê°„ ë¶„ë¥˜ ìš”ì•½ ì •ë¦¬(Storage Classes)

<img width="900" alt="image" src="https://github.com/user-attachments/assets/c6476aae-9556-4ab9-9771-b309bb92c7b8" />


### ğŸ“Œ 12.11 í•¨ìˆ˜ì˜ ì €ì¥ ê³µê°„ ë¶„ë¥˜(Storage Classes and Functions)
- Functions external (by default) or static. A function declaration is assumed to be extern.  
  í•¨ìˆ˜ ë° í”„ë¡œí† íƒ€ì… ì„ ì–¸ ì‹œ externì´ ê¸°ë³¸ì´ë‹¤. (static ì‚¬ìš© ì‹œ ë™ì¼í•˜ê²Œ fileì•ˆì—ì„œë§Œ.)  
  ì™œ staticìœ¼ë¡œ ë§‰ì•„ë†“ì„ê¹Œ? -> í•´ë‹¹ Module(file)ì—ì„œë§Œ ì‚¬ìš©í•˜ëŠ” í•¨ìˆ˜ë¼ë©´.


### ğŸ“Œ 12.12 ë‚œìˆ˜ ìƒì„±ê¸° ëª¨ë“ˆ ë§Œë“¤ê¸° ì˜ˆì œ
<img width="900" alt="image" src="https://github.com/user-attachments/assets/27d16028-d29f-405f-b8fc-c8f54d6eb4bc" />


### ğŸ“Œ 12.13 ë©”ëª¨ë¦¬ ë™ì  í• ë‹¹(Dynamic Storage Allocation)
- runtimeì— ë©”ëª¨ë¦¬ê°€ ê²°ì •ë˜ëŠ” ê²½ìš° heap ì˜ì—­ ì‚¬ìš©. (=í•„ìš”í•œ ë©”ëª¨ë¦¬ì˜ í¬ê¸°ë¥¼ ë¯¸ë¦¬ ì•Œ ìˆ˜ ì—†ëŠ” ê²½ìš°)  
  mallocì€ void í¬ì¸í„°ë¥¼ ë°˜í™˜í•˜ê¸° ë•Œë¬¸ì—, ì•ì— castingì„ í•´ì„œ ì‚¬ìš©í•œë‹¤.  
  ex) ptr = `(double*)`malloc(30 * sizeof(double));
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>	// malloc(), free()

int main()
{
	float x;
	char str[] = "Dancing with a Star";

	int arr[100];


	/*
		malloc() returns a void type pointer.  
		void* : generic pointer

		free() deallocates the memory
	*/

	double* ptr = NULL;

	ptr = (double*)malloc(30 * sizeof(double));

	if (ptr == NULL)
	{
		puts("Memory allcation failed.");

		// exit(EXIT_FAILURE) is similar to return 1 IN main().
		// exit(EXIT_SUCCESS) is similar to return 0 IN main().
		// return 0; ì€ í•¨ìˆ˜ ë‚´ë¶€ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥í•˜ì§€ë§Œ, <stdlib.h>ì˜ exit()ì€ ì–´ë””ì„œë‚˜ ê°€ëŠ¥.
		// C ì–¸ì–´ì—ì„œ exit(EXIT_FAILURE);ëŠ” Pythonì˜ raise Exceptionê³¼ ë¹„ìŠ·í•œ ì—­í• 
		exit(EXIT_FAILURE);
	}

	printf("Before free %p\n", ptr);

	free(ptr);	// no action occurs when ptr is NULL

	printf("After free %p\n", ptr);

	// freeë¡œ ë©”ëª¨ë¦¬ ë°˜í™˜ ì´í›„, ptrì— ê¸°ì¡´ ì£¼ì†Œê°’ì´ ë“¤ì–´ìˆìœ¼ë¯€ë¡œ NULL ëŒ€ì….
	// = ì•„ë¬´ê²ƒë„ ê°€ë¦¬í‚¤ê³  ìˆì§€ ì•Šë‹¤. ë¼ê³  ëª…ì‹œ.
	ptr = NULL;



	/* Dynamically Allocated Array */

	int n = 5;
	// ... 
	ptr = (double*)malloc(n * sizeof(double));  // casting, expression ...

	if (ptr != NULL)	// if(!ptr)
	{
		for (int i = 0; i < n; ++i)
			printf("%f ", ptr[i]);  // ë°°ì—´ì²˜ëŸ¼ ì‚¬ìš© ê°€ëŠ¥
		printf("\n");


		for (int i = 0; i < n; ++i)
			*(ptr + i) = (double)i;  // í¬ì¸í„° ì—°ì‚° ê°€ëŠ¥

		for (int i = 0; i < n; ++i)
			printf("%f ", ptr[i]);
		printf("\n");
	}

	free(ptr);
	ptr = NULL;

	/*
		Comparision to VLA

		VLA
		- not supported by VS compilers.
		- automatic duration, cannot be resized
		- limited by stack size (when compiler places VLA in stack segment)
	*/

	return 0;
}
```


### ğŸ“Œ 12.14 ë©”ëª¨ë¦¬ ëˆ„ìˆ˜(Leak)ì™€ free()ì˜ ì¤‘ìš”ì„± + VS Diagnostic Tool
- ptrì€ ë°›ì•„ì˜¨ ë©”ëª¨ë¦¬ë¥¼ í™œìš©í•˜ê³  block scopeë¥¼ ë²—ì–´ë‚˜ë©´ì„œ ì‚¬ë¼ì¡Œì§€ë§Œ,  
  heapì—ì„œ í• ë‹¹ë°›ì€ ë©”ëª¨ë¦¬ëŠ” free(), í•´ì œí•´ì£¼ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì— ìœ ì§€ë˜ê³  ìˆë‹¤.  
  <img width="700" alt="image" src="https://github.com/user-attachments/assets/bbeb6801-ee28-4163-92e8-6d5fe3211f75" />
  ë§Œì•½ ë°˜ë³µë¬¸ì—ì„œ ê³„ì† leakê°€ ìˆë‹¤ë©´,  
  <img width="700" alt="image" src="https://github.com/user-attachments/assets/44f063e0-3011-4230-b76c-83382303eab6" />
- free()í›„ Memory usage (heap ë©”ëª¨ë¦¬ ë°˜ë‚©)  
  Tip : ë™ì í• ë‹¹ì€ block ì•ˆì—ì„œ í™œìš©í•˜ê³ , scopeë¥¼ ë²—ì–´ë‚  ë•Œ í•´ì œ ë° NULLì²˜ë¦¬ë¥¼ í•´ì£¼ëŠ” í¸ì´ ì¢‹ë‹¤.  
  <img width="700" alt="image" src="https://github.com/user-attachments/assets/04f84401-69d8-407b-9670-b0a54f19b31a" />


### ğŸ“Œ 12.15 ë™ì  í• ë‹¹ ë©”ëª¨ë¦¬ë¥¼ ë°°ì—´ì²˜ëŸ¼ ì‚¬ìš©í•˜ê¸°
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

int main()
{
	/*
		One variable
	*/

	int* ptr = NULL;

	ptr = (int*)malloc(sizeof(int) * 1);
	if (!ptr) exit(1);

	*ptr = 1024 * 3;
	printf("%d\n", *ptr);

	free(ptr);
	ptr = NULL;



	/*
		1D array
	*/

	int n = 3;
	int * ptr = (int*)malloc(sizeof(int) * n);
	if (!ptr) exit(1);

	ptr[0] = 123;
	*(ptr + 1) = 456;
	*(ptr + 2) = 789;

	free(ptr);
	ptr = NULL;



	/*
		2D array
	*/

	int row = 3, col = 2;
	int(*ptr2d)[2] = (int(*)[2])malloc(sizeof(int) * row * col);
	//int(*ptr2d)[col] = (int(*)[col])malloc(sizeof(int) * row * col);// VLA
	if (!ptr2d) exit(1);

	for (int r = 0; r < row; r++)
		for (int c = 0; c < col; c++)
			ptr2d[r][c] = c + col * r;

	for (int r = 0; r < row; r++)
	{
		for (int c = 0; c < col; c++)
			printf("%d ", ptr2d[r][c]);
		printf("\n");
	}



	/*
		Using 1D arrays as 2D arrays

		row = 3, col = 2

		(r, c)

		2D
		(0, 0) (0, 1)
		(1, 0) (1, 1)
		(2, 0) (2, 1)

		1D
		(0, 0) (0, 1) (1, 0) (1, 1) (2, 0) (2, 1)
		0      1      2      3      4      5      = c + col * r

	*/

	int row = 3, col = 2;
	int* ptr = (int*)malloc(row * col * sizeof(int));
	if (!ptr) exit(1);

	for (int r = 0; r < row; ++r)
	{
		for (int c = 0; c < col; ++c)
			ptr[c + col * r] = c + col * r;
	}
		
	for (int r = 0; r < row; ++r)
	{
		for (int c = 0; c < col; ++c)
			printf("%d ", *(ptr + c + col * r));
		printf("\n");
	}


	/*
		Using 1D arrays as 3D arrays

		row = 3, col = 2, depth = 2

		(r, c, d)

		3D
		-------------------
		(0, 0, 0) (0, 1, 0)
		(1, 0, 0) (1, 1, 0)
		(2, 0, 0) (2, 1, 0)
		-------------------
		(0, 0, 1) (0, 1, 1)
		(1, 0, 1) (1, 1, 1)
		(2, 0, 1) (2, 1, 1)
		-------------------

		1D
		(0, 0, 0) (0, 1, 0) (1, 0, 0) (1, 1, 0) (2, 0, 0) (2, 1, 0) (0, 0, 1) (0, 1, 1)	(1, 0, 1) (1, 1, 1) (2, 0, 1) (2, 1, 1)
		0         1         2         3         4         5         6         7         8         9         10        11
		= c + col * r + (col*row) * d
		= 1 + 2 * 1 + (3*2) * 1 = 1 + 2 + 6 = 9

		3D
		row, col, depth, height
		(r, c, d, h)
		index = c + col * r + (col*row) * d + (row * col * depth) * h
	*/


	// my_code
	int row = 3, col = 3, dep = 2;
	int* ptr = (int*)malloc(row * col * dep * sizeof(int));
	if (!ptr) exit(1);

	for (int d = 0; d < dep; ++d)
		for (int r = 0; r < row; ++r)
			for (int c = 0; c < col; ++c)
				ptr[c + (col) * r + (col * row) * d] = c + (col) * r + (col * row) * d;

	for (int d = 0; d < dep; ++d)
	{
		for (int r = 0; r < row; ++r)
		{
			for (int c = 0; c < col; ++c)
			{
				printf("%d ", *(ptr + c + (col) * r + (col * row) * d));
			}
			printf("\n");
		}
		printf("\n");
	}


	// teacher
	int row = 3, col = 2, depth = 2;
	int* ptr = (int*)malloc(row * col * depth * sizeof(int));
	if (!ptr) exit(1);

	for (int d = 0; d < depth; d++)
		for (int r = 0; r < row; r++)
			for (int c = 0; c < col; c++)
				ptr[c + col * r + (col * row) * d] = c + col * r + (col * row) * d;
	/*
		int idx2(int c, int r)  <- í•¨ìˆ˜í™”!
		{
			return c + col * r;
		}

		int idx3(int c, int r, int d)
		{
			static const int cr = col * row;
			return c + col * r + cr * d;
		}
	*/
	for (int d = 0; d < depth; d++)
	{
		for (int r = 0; r < row; r++)
		{
			for (int c = 0; c < col; c++)
				printf("%d ", *(ptr + c + col * r + (col * row) * d));
			printf("\n");
		}
		printf("\n");
	}

	return 0;
}
```


### ğŸ“Œ 2darray
``` c
#include <stdio.h>
#include <stdlib.h>

int main()
{
	int row = 3, col = 2;

	//int** ptr = (int**)malloc(row * sizeof(int*));
	//for (int i = 0; i < row; ++i)
	//	ptr[i] = (int*)malloc(col * sizeof(int));

	//for (int i = 0; i < row; ++i)
	//	for (int l = 0; l < col; ++l)
	//		ptr[i][l] = l + col * i;

	//for (int i = 0; i < row; ++i)
	//{
	//	for (int l = 0; l < col; ++l)
	//		printf("%d ", ptr[i][l]);
	//	printf("\n");
	//}
	//
	//for (int i = 0; i < row; ++i)
	//	free(ptr[i]);
	//free(ptr);


	//int* ptr = (int*)malloc(row * col * sizeof(int));
	//int(*ptr2d)[1] = (int(*)[1])malloc(row * col * sizeof(int));

	//int(*ptr2d)[2] = (int(*)[2])malloc(row * col * sizeof(int));

	int** ptr2d = (int**)malloc(row * sizeof(int*));
	if (!ptr2d) exit(1);

	for (int i = 0; i < row; i++)
	{
		ptr2d[i] = (int*)malloc(col * sizeof(int));
		if (!ptr2d[i]) exit(1);
	}


	for (int n = 0; n < row; n++)
		for (int m = 0; m < col; m++)
			ptr2d[n][m] = m + col * n;

	for (int n = 0; n < row; n++)
	{
		for (int m = 0; m < col; m++)
			printf("%d ", ptr2d[n][m]);
		printf("\n");
	}

	for (int i = 0; i < row; i++)
		free(ptr2d[i]);
	free(ptr2d);


	return 0;
}
```


### ğŸ“Œ 12.16 calloc(), realloc()
<img width="700" alt="image" src="https://github.com/user-attachments/assets/e898cb6b-4502-4f26-88fb-0a009e2e3329" />

``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

int main()
{
	int n = 10;

	int* ptr = NULL;

	//ptr = (int*)malloc(sizeof(int) * n);
	// calloc : ì—°ì†ì ì¸ í• ë‹¹.
	// @@@@@ ì´ˆê¸°í™” í•´ì¤€ë‹¤ @@@@@
	ptr = (int*)calloc(n, sizeof(int));// contiguous allocation
	if (!ptr)
		exit(1);

	for (int i = 0; i < n; ++i)
		printf("%d ", ptr[i]);  // 0 0 0 0 0 0 0 0 0 0
	printf("\n");


	/*
		realloc() KNK p. 422
		- doesn't initialize the bytes added
		- returns NULL if can't enlarge the memory block
		- If first argument is NULL, it behaves like malloc()
		- if second argument is 0, it frees the memory block.

		- ì¶”ê°€ëœ ë°”ì´íŠ¸ë¥¼ ì´ˆê¸°í™”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
		- ë©”ëª¨ë¦¬ ë¸”ë¡ì„ í™•ëŒ€í•  ìˆ˜ ì—†ëŠ” ê²½ìš° NULLì„ ë°˜í™˜í•©ë‹ˆë‹¤.
		- ì²« ë²ˆì§¸ ì¸ìˆ˜ê°€ NULLì´ë©´ malloc()ì²˜ëŸ¼ ì‘ë™í•©ë‹ˆë‹¤.
		- ë‘ ë²ˆì§¸ ì¸ìˆ˜ê°€ 0ì´ë©´ ë©”ëª¨ë¦¬ ë¸”ë¡ì„ í•´ì œí•©ë‹ˆë‹¤.

		- malloc -> realloc ê°€ëŠ¥.
	*/

	for (int i = 0; i < n; ++i)
		ptr[i] = i + 1;

	n = 20;

	int* ptr2 = NULL;
	ptr2 = (int*)realloc(ptr, n * sizeof(int));
	//ptr = (int*)realloc(ptr, n * sizeof(int));

	printf("%p %p\n", ptr, ptr2);  // 000002C66E366210 000002C66E35B0D0

	printf("%d\n", ptr[0]);

	if (!ptr2)
		exit(1);
	else
		ptr = NULL;

	for (int i = 0; i < n; ++i)
		printf("%d ", ptr2[i]);		// 1 2 3 4 5 6 7 8 9 10 -842150451 -842....
	printf("\n");

	free(ptr2);

	return 0;
}
```


### ğŸ“Œ 12.17 ë™ì  í• ë‹¹ ë©”ëª¨ë¦¬ì™€ ì €ì¥ ê³µê°„ ë¶„ë¥˜
<img width="700" alt="image" src="https://github.com/user-attachments/assets/ad09d04a-e0d4-46a6-9f43-fe41f4aba9d0" />


### ğŸ“Œ 12.18 ìë£Œí˜• í•œì •ìë“¤ (Type Qualifiers) const, volatile, restrict
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>	// memcpy
#include "constants.h"

//const double gravity = 9.8;
//const double PI = 3.141592;

int main()
{
	double area_circle = PI * 2.0f * 2.0f;

	/*
		Qualified types
		const, volatile, restrict, _Atomic

		_Atomicì€ ë©€í‹°ì“°ë ˆë”©ì— ì‚¬ìš©ë  ì˜ˆì •.
	*/

	/*
		const
	*/

	// C99 ideompotent - íƒ€ì…í•œì •ìë¥¼ ì—¬ëŸ¬ê°œ ì¨ë„ ê´œì°®ë‹¤.
	const const const int n = 6;// const int n = 6;

	typedef const int zip;
	const zip q = 8;// const const int zip

	//const int i;	// NOT initialized!
	//i = 12;//Error
	//printf("%d\n", i);//Error

	const int j = 123;  // constë¥¼ ì„ ì–¸í•  ë•ŒëŠ” ê¼­ ì´ˆê¸°í™”ë¥¼ í•´ì•¼í•œë‹¤. (ì´í›„ì— ë³€ê²½ì´ ì•ˆë˜ë‹ˆê¹Œ.)
	const int arr[] = { 1, 2, 3 };

	float f1 = 3.14f, f2 = 1.2f;

	const float* pf1 = &f1;  // ê°’ ë³€ê²½ x, ì£¼ì†Œê°’ ë³€ê²½ o
	//*pf1 = 5.0f;//Error
	pf1 = &f2;// Allowed

	float* const pf2 = &f1;  // ê°’ ë³€ê²½ o, ì£¼ì†Œê°’ ë³€ê²½ x

	*pf2 = 6.0f;
	//pf2 = &f2;//Error

	const float* const pf3 = &f1;  // ê°’ ë³€ê²½ x, ì£¼ì†Œê°’ ë³€ê²½ x
	//*pf3 = 7.0f;//Error
	//pf3 = &pf2;//Error



	/*
		Global constants
	*/

	/*
		compilerê°€ ëª¨ë¥´ëŠ” ìƒí™©ì—ì„œ ê°’ì´ ë³€í•  ìˆ˜ ìˆë‹¤ê³  í‘œê¸°.
		ê·¸ëŸ¬ë‹ˆê¹Œ ìµœì í™” í•˜ì§€ ë§ˆë¼. (ex. (ì„ì‹œì €ì¥ì†Œ)cashingì„ ëª»í•˜ê²Œ.)

		volatile
		- Do not optimize
		- (ex: hardward clock)
	*/

	volatile int vi = 1;	// volatile location
	volatile int* pvi = &vi;	// points to a volatile location

	int i1 = vi;

	// ...

	int i2 = vi;



	/*
		restrict (__restrict in VS)
		- sole initial means of accessing a data object
		- compiler can't check this restriction

		ì œí•œ (VSì—ì„œ__ì œí•œ)
		- ë°ì´í„° ê°ì²´ì— ì•¡ì„¸ìŠ¤í•˜ëŠ” ìœ ì¼í•œ ì´ˆê¸° ìˆ˜ë‹¨
		- ì»´íŒŒì¼ëŸ¬ê°€ ì´ ì œí•œì„ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤
		  (ì œí•œëœ í¬ì¸í„°ë¡œë§Œ ì ‘ê·¼í•˜ì.)
	*/

	int ar[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	int* par = ar;

	int* __restrict restar = (int*)malloc(10 * sizeof(int));
	if (!restar)exit(1);

	ar[0] += 3;
	par[0] += 5;
	// par[0] += 8;

	restar[0] += 3;
	restar[0] += 5;
	//restar[0] += 8;// Equalivalent

	free(restar);

	return 0;
}
```


### ğŸ“Œ 12.19 ë©€í‹° ì“°ë ˆë”©(Multi-Threding)
- ë™ì‹œì„± í”„ë¡œê·¸ë˜ë°  
  <img width="500" alt="image" src="https://github.com/user-attachments/assets/11fe1bba-ee98-41db-8973-25849da1b45f" />
  
- ê°™ì€ í•¨ìˆ˜ë¥¼ ì—¬ëŸ¬ê°œì˜ ì“°ë ˆë“œê°€ ë™ì‘ì‹œí‚¬ ë•Œ, í•´ë‹¹ í•¨ìˆ˜ ì•ˆì— ìˆëŠ” ì§€ì—­ë³€ìˆ˜ëŠ” ì–´ë–¤ storage classë¥¼ ê°–ëŠ”ì§€. -> `thread storage duration` (ì§€ì—­ë³€ìˆ˜ì™€ ë™ì¼)  
  í•˜ë‚˜ì˜ ì „ì—­ë³€ìˆ˜ë¥¼ ì—¬ëŸ¬ê°œì˜ ì“°ë ˆë“œê°€ ì ‘ê·¼í•˜ë©´, ê²½ìŸì´ ìƒê¸´ë‹¤. -> racing(ê²½ìŸ)ì„ ë§‰ì•„ì¤€ë‹¤. `atomic type qualifer` (C11) (but, ë§ì€ ë°˜ë³µ ì—°ì‚°ì€ ëŠë¦¬ê¸° ë•Œë¬¸ì— atomicì€ í”¼í•œë‹¤.)

``` c 
//// VS
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <windows.h>

//_Atomic int acnt = 0; //NA

DWORD WINAPI ThreadFunc(void* data)
{
	int n = 1;
	Sleep(1000);

	//acnt += n;	//NA
	printf("Printing from Thread \n");
	return 0;
}

int main()
{
	HANDLE thread = CreateThread(NULL, 0, ThreadFunc, NULL, 0, NULL);
	
	if (thread) 
		WaitForSingleObject(thread, INFINITE);
}

//// GCC
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>  // sleep().
#include <pthread.h>
#include <stdatomic.h>

_Atomic int acnt = 0;// atomic type qualifer (C11)

// A normal C function that is executed as a thread
// when its name is specified in pthread_create()
void *myThreadFun(void *vargp)
{
	int n = 1;// thread storage duration
	for (int j = 0; j < 10; ++j)
	{
		sleep(1);
		acnt += n;
		printf("Printing from Thread %d %llu\n", acnt, (unsigned long long)&n);
	}

	return NULL;
}

int main()
{
	pthread_t thread_id1, thread_id2;

	printf("Before Thread\n");

	pthread_create(&thread_id1, NULL, myThreadFun, NULL);
	pthread_create(&thread_id2, NULL, myThreadFun, NULL);

	pthread_join(thread_id1, NULL);  // <- ì“°ë ˆë“œê°€ ëë‚ ë•Œê¹Œì§€ ê¸°ë‹¤ë ¤ì¤€ë‹¤.
	pthread_join(thread_id2, NULL);  // ì“°ë ˆë“œì— ì¼ ì‹œì¼œë†“ê³  main í•¨ìˆ˜ê°€ ëë‚˜ë²„ë¦¬ë©´ ì˜ë¯¸ê°€ ì—†ê¸°

	printf("After Thread\n");
	printf("Atomic %d\n", acnt);
	return 0;
}


// To compile
// 	$ gcc <file-name.c> -o <output-file-name> -lpthread
// To run
// 	$ ./<output-file-name>
```
