### 📌 11.1 문자열을 정의하는 방법들
``` c
#include <stdio.h>

#define MESSAGE "A symbolic string contant"
#define MAXLENGTH 81

int main()
{
	// 넉넉하게 메모리를 먼저 주고 그 안에 담는다.
	char words[MAXLENGTH] = "A string in an array";
	const char* pt1 = "A pointer to a string.";

	puts("Puts() adds a newline at the end:");// 알아서 backslash n 붙혀줌. puts() add \n at the end
	puts(MESSAGE);
	// MAXLENGTH만큼 모드 초기화 하지 않았기 때문에, char words[21] removes this warning
	puts(words);	// 문자열을 넣거나,
	puts(pt1);		// 문자열에 대한 포인터를 넣거나.
	words[3] = 'p';	// OK
	puts(words);
	//pt1[8] = 'A';	// Error
	// 읽기 전용 메모리에 저장된 데이터 값을 바꾸려고 시도하면 운영체제에서 중단시킨다.
	// 배열은 읽기/쓰기가 모두 가능한 메모리를 사용합니다.
	// 문자열 리터럴은 프로그램의 일부이기 떄문에 읽기 전용 메모리에 저장되어 있습니다.
	// (일단 배열 표기법(pt1[8])은 포인터 연산(*(pt1 + 8))과 완전히 동일)

	char greeting[50] = "Hello, and"" How are" " you"
		" today!";
	// char greeting[50] = "Hello, and How are you today!";
	puts(greeting);

	printf("\" To be, or not to be\" Hamlet said.\n");

	// *****
	printf("%s, %p, %c\n", "We", "are", *"excellent programmers");  // We, 00007FF7EBE6B044, e

	// 1)
	const char m1[15] = "Love you!";
	for (int i = 0; i < 15; ++i)
		printf("%d ", (int)m1[i]);	// 76 111 118 101 32 121 111 117 33 0 0 0 0 0 0
	printf("\n");

	// 2) 맨 뒤에 NULL 필수.
	const char m2[15] = { 'L', 'o', 'v', 'e', ' ', 'y', 'o', 'u', '!', '\0' };
	for (int i = 0; i < 15; ++i)
		printf("%d ", (int)m2[i]);	// Note the null characters
	printf("\n");

	// 3) 메모리 할당 사이즈 미정의
	const char m3[] = "Love you, too!";


	int n = 8;
	char cookies[1] = { 'A', };
	char cakes[2 + 5] = { 'A', };
	char pies[2 * sizeof(long double) + 1] = { 'A', };
	//char crumbs[n]; // VLA

	char truth[10] = "Truths is ";
	if (truth == &truth[0]) puts("true!");		// 배열 이름은 배열의 첫번째 주소
	if (*truth == 'T') puts("true!");			// indirection하면 첫글자
	if (*(truth + 1) == truth[1]) puts("true!");// 포인터 연산
	if (truth[1] == 'r') puts("true!");			// indexing해서 값 비교, 가져오기 가능.

	return 0;
}
```


### 📌 11.2 메모리 레이아웃과 문자열(Memory Layout)
<img width="650" src="https://github.com/user-attachments/assets/9502f8e2-bd8f-490b-aa92-54f4d5977f2e"/>

<img width="650" src="https://github.com/user-attachments/assets/b2dab408-ace0-4890-b29c-3afeefc0d11e"/>
<img width="650" src="https://github.com/user-attachments/assets/2d5fe970-c5e4-4c3b-8d8a-3ba8583a2a51"/>
<img width="650" src="https://github.com/user-attachments/assets/89e353ba-ca05-456d-8d28-2cd6aeb2b7bd"/>
<img width="650" src="https://github.com/user-attachments/assets/dab8f896-94f3-4ac8-b56c-63adba950a32"/>

- (주소가 높음)  
  1) Stack  
  컴파일러가 '이 변수는 이정도 메모리가 필요하겠구나' = `메모리 크기를 컴파일러가 예측할 수 있는 경우`, Stack memory를 사용.  
  메모리를 운영체제에게 새로 받아올 때 속도가 빠르다. 지역변수들이 이곳에 담긴다.  
  2) Heap  
  메모리 크기를 컴파일러가 예측할 수 없는 경우, Heap memory를 사용.  
  5) TEXT segment. (프로그램 코드)  
  작성 후 컴파일 한 프로그램은 크기가 고정되어 있음.  
  또한 프로그램이 실행되는 중간에 바뀌어 버리는 것을 막기 위하여 `읽기 전용 메모리`에 담는다.  
  (주소가 낮음)
- 배열로 선언된 arr은 DATA segment로 복사됨. = arr `배열은 그 자체로 메모리를 확보`하고 있으니까 수정이 가능하다. (문자열이 메모리로 복사되면서 들어간다.)  
  str은 포인터. 주소를 가리키기만 하고, 이 데이터가 담겨있는 메모리(string literal) 공간을 편집할 수 있는 권한은 없다.  
  "str[0] = 'M';의 runtime error 이유는?"  
  여러 포인터가 동일한 문자열을 가리켜도 string literal의 값이 변경되지 않는다.  
  (compile time에 이미 문자열 내용이 정해져 있으므로) 읽기 전용 메모리에 있기 때문에 운영체제가 막아버려서 문제가 발생한다.

``` c
#include <stdio.h>
#include <stdlib.h>	// malloc

void test_function()
{
	int j;
	printf("Stack high \t%llu\n", (unsigned long long) & j);
}

int main()
{
	/* Array Versus Pointer */
	const char* pt2 = "I am a string!.";
	const char* pt3 = "I am a string!.";
	const char* pt4 = "I am a string!!!!!!."; // <- different
	const char ar1[] = "I am a string!.";
	const char ar2[] = "I am a string!.";
	const char ar3[] = "I am a string!!.";	// <- different

	/* Memory address check */
	// rodata low      140702528089888 140702528089888 140702528089912 140702528089888
	printf("rodata low \t%llu %llu %llu %llu\n",
		(unsigned long long)pt2, (unsigned long long)pt3, (unsigned long long)pt4,
		(unsigned long long)"I am a string!.");

	// Stack high      1093464618696 1093464618744 1093464618792
	printf("Stack high \t%llu %llu %llu\n", (unsigned long long)ar1,
		(unsigned long long)ar2, (unsigned long long)ar3);// check address numbers!

	// Stack high      1093464618600 1093464618632 1093464618664 (포인터 주소는 당연히 다르다.)
	printf("Stack high \t%llu %llu %llu\n",
		(unsigned long long) & pt2, (unsigned long long) & pt3, (unsigned long long) & pt4);



	/* Local variables */
	// Stack high      1093464618836
	int i;
	printf("Stack high \t%llu\n", (unsigned long long) & i);

	/* Local variable in a function*/
	// Stack high      1093464618292
	test_function();



	/* Dynamic allocation, 동적할당 */ 
	// Heap middle     2449217007824
	char* p5 = (char*)malloc(sizeof(char) * 100);
	printf("Heap middle \t%llu\n", (unsigned long long)p5);

	// Heap middle     2449217007152
	char* p6 = (char*)malloc(sizeof(char) * 100);
	printf("Heap middle \t%llu\n", (unsigned long long)p6);



	/* Array Versus Pointer (continued) */
	const char* pt5 = "I am a string!!!!!!.";
	const char ar4[] = "I am a string!.";

	//ar4++;	// Error (array)
	pt5++;		// OK (pointer)
	puts(pt5);	// ' am a string!!!!!!.' -> 포인터 밀려서 앞글자 날라감



	/* Array and Pointer Differences */
	char heart[] = "I love Kelly!";
	const char* head = "I love Helly!";

	for (int i = 0; i < 6; i++)
		putchar(heart[i]);		//Note: putchar() outputs a single character
	putchar('\n');  // I love

	for (int i = 0; i < 6; i++)
		putchar(head[i]);		//Note: putchar() outputs a single character
	putchar('\n');  // I love

	// pointer addition
	for (int i = 0; i < 6; i++)
		putchar(*(heart + i));
	putchar('\n');  // I love

	for (int i = 0; i < 6; i++)
		putchar(*(head + i));
	putchar('\n');  // I love

	while (*(head) != '\0')
		putchar(*(head++));  // I love Helly!

	// (배열이 이름은 포인터로 호환이 되므로) 포인터 수정 가능, string literal 수정 불가.
	head = heart;
	//heart = head;	// Error

	// Cannot change heart. Can change the elements of heart
	heart[7] = 'H';		// Note: character
	*(heart + 7) = 'K';

	putchar('\n');

	// 포인터가 갖고 있는게 아니고 data segment에 있는 메모리를 가리키는 건데
	//Note: const char * word = "Goggle"; is recommended
	char* word = "Goggle";
	//word[2] = 'o';		// Run-time error!
	puts(word);



	/* 깊은 복사, 얕은 복사. */ 
	const char *str1 = "When all the lights are low, ...";
	const char *copy;

	copy = str1;  // 주소만 복사하고 있다.

	// 포인터 변수 자체는 stack에 있으며, 복사한 건 다르다.
	printf("%s %p %p\n", str1, str1, &str1);  // When all the lights are low, ... 00007FF6172BB158 00000019228FF718
	printf("%s %p %p\n", copy, copy, &copy);  // When all the lights are low, ... 00007FF6172BB158 00000019228FF738

	//Note: strcpy(), strncpy()

	return 0;
}
```



