### 📌 9.1 함수가 필요할 때
- 1. 기능을 확장해야 할 때  
  2. 같은 기능이 여려번 반복될 때    


### 📌 9.2 함수의 프로토타입
- C에서 함수를 Black Box처럼 사용하면 모듈화, 유지보수, 재사용성이 증가  
  `Black Box 개념`이란 함수의 내부 구현을 신경 쓰지 않고, `입력과 출력만 고려해서 사용하는 방식`을 의미함.  
  C++에서 객체지향(OOP)의 캡슐화, 다형성과 결합되면 더욱 강력한 코드 설계 가능
- 입력과 출력이 뭔지만 알면,(=prototype만 알면) 컴파일은 가능.
  → prototype만 넣고 `Bulid(compile + linking)`를 시작해서 아웃풋을 보면 compile은 지나가고 linking에서 오류가 생긴다. (body가 없으니까)
- (사용하는 입장에서는 argument, 함수에서는 parameter)
- main 함수에서 function에 값을 `넣을 때는 (actual) argument(인자)`,  
  function이 정의되어 있는 곳`(받는 곳)에서는 (formal) parameter(매개변수)`이다.
- void function_name () → 안넣어도 되지만, 경고.  
  void function_name (void) → argument에는 넣을 건데 prototype에 void 입력하면 에러.  
  void function_name (char, int, bool) → 어떤 자료형으로 IO가 이루어져있는지만 알면 되기 때문에 문제 없음.  
  void function_name (char c, int n_stars, bool print_newline) → 함수 정의와 똑같이 적는 것을 일단 권장.  
``` c
#include <stdio.h>
#include <string.h>	// strlen()
#include <stdbool.h>
#include "8.h"

#define WIDTH	25
#define NAME	"Jeong-Mo Hong"
#define ADDRESS "Seoul, Korea"

void print_multiple_chars(char c, int n_stars, bool print_newline);
void print_centered_str(char str[]);

int main()
{
	print_multiple_chars('*', WIDTH, true);

	print_centered_str(NAME);
	print_centered_str(ADDRESS);
	print_centered_str("I love you");

	print_multiple_chars('*', WIDTH, false);

	return 0;
}

void print_multiple_chars(char c, int n_stars, bool print_newline)
{
	for (int i = 0; i < n_stars; ++i)
		printf("%c", c);	// putchar(c)

	if (print_newline)
		printf("\n");
}

void print_centered_str(char str[])
{
	int n_blanks = 0;
	n_blanks = (int)((size_t)WIDTH - strlen(str)) / 2;
	print_multiple_chars(' ', n_blanks, false);
	printf("%s\n", str);
}
```


### 📌 9.3 함수의 자료형과 반환값
- 반환 자료형을 함수의 자료형처럼 생각할 수 있다. ex. `int` func(int)  
  반환 자료형이 int일 경우, 문법상 생략해도 문제는 없다. (= `default가 int`)
- 다양한 반환 자료형이 필요할 때 사용하는 것이 구조체.
- if, else 어느 쪽도 해당이 안되는 경우는 이례적이므로, 그 뒤에 exit이나 로그 경고 문구를 넣어주는 편이 좋다.
``` c
#include <stdio.h>

int int_min(int, int);

int main()
{
	int i1, i2;

	while (1)
	{
		printf("Input two integers : ");

		if (scanf("%d %d", &i1, &i2) != 2) break;

		int lesser = int_min(i1, i2);
		//int lesser = min;
		printf("The lesser of %d and %d is %d\n", i1, i2, lesser);

		//printf("The lesser of %d and %d is %d\n", i1, i2, int_min(i1, i2));

	}

	printf("End.\n");

	return 0;
}

int int_min(int i, int j)
//int_min(int i, int j)
{
	// 1
	int min;

	if (i < j)
		min = i;
	else
		min = j;

	return min;


	// 2
	return (i < j) ? i : j;


	// 형 변환
	return (float)min;  // argument 쪽에서 int로 받기 때문에 warning.


	// 3
	if (i < j)
		return i;
	else
		return j;

	// error
	printf("ERROR");
	exit(1);

	//return; // return with no value
}
```


### 📌 9.4 변수의 영역과 지역 변수(Stack Frame, scope, Local variable)
- Stack Frame.  
  스택 프레임(Stack Frame)은 함수가 호출될 때 생성되는 메모리 블록으로,  
  지역 변수, 매개변수, 반환 주소, 저장된 레지스터 정보 등이 포함됨.  
  함수가 종료되면 해당 스택 프레임은 스택에서 제거됨(POP).
- Scope. (6.18 참고)  
  지역 변수(local variable) → 함수가 호출될 때 `스택 프레임`에 저장되며, 함수 종료 시 제거됨.  
  전역 변수(global variable) → `데이터 영역`에 저장되며 프로그램이 종료될 때까지 유지됨.  
  정적 변수(static variable) → `데이터 영역`에 저장되며, 프로그램 실행 동안 값이 유지됨.
``` c
#include <stdio.h>

void counter() {
	static int count = 0;  // 함수가 호출될 때마다 값이 유지됨
	count++;
	printf("Count: %d\n", count);
}

int main() {
	counter();  // 출력: Count: 1
	counter();  // 출력: Count: 2
	counter();  // 출력: Count: 3
	return 0;
}
```
``` c
#include <stdio.h>

//int a;  // (파일) 전역 변수

int int_max(int i, int j);

int main()
{
	int a;  // 지역 변수

	a = int_max(1, 2);

	printf("%d\n", a);  // 2
	printf("%p\n", &a);  // 0000006E3E9CF584  // 주소 출력

	{
		int a;
		a = int_max(4, 5);

		printf("%d\n", a);  // 5
		printf("%p\n", &a);  // 0000001B56F7F744  // 주소에 변동

		int b = 123;
	}

	printf("%d\n", a);  // 2
	printf("%p\n", &a);  // 0000006E3E9CF584

	return 0;
}

int int_max(int i, int j)
{
	//a = 456;
	int m;
	m = i > j ? i : j;
	return m;
}
```


### 📌 9.5 지역 변수와 스택
















