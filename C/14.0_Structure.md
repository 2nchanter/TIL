### ğŸ“Œ 14.1 êµ¬ì¡°ì²´(Structures)ê°€ í•„ìš”í•œ ì´ìœ 
- ë°°ì—´ì€ ìë£Œí˜•ì´ ê°™ì€ ë°ì´í„°ë§Œ ëª¨ì„ ìˆ˜ ìˆëŠ”ë°, ë‹¤ë¥¸ ìë£Œí˜•ì€ ì–´ë–»ê²Œ?
<img width="800" alt="image" src="https://github.com/user-attachments/assets/1d45327c-4844-47c6-9f30-16d270c5891f" />


### ğŸ“Œ 14.2 êµ¬ì¡°ì²´ì˜ ê¸°ë³¸ì ì¸ ì‚¬ìš©ë²•
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX 41

// ì¿ í‚¤ í‹€ì´ ì´ëŸ° í˜•íƒœì¼ê±°ë‹¤!
struct person	/* Person is a tag of strcture*/
{
	char name[MAX];	// member
	int age;		// member
	float height;	// member
};

int main()
{
	int flag;// Receives return value of scanf()



	/* Structure variable */
	struct person genie;  // êµ¬ì¡°ì²´ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ëŠ” ìˆœê°„ ë©”ëª¨ë¦¬ê°€ í• ë‹¹ëœë‹¤.

	// dot(.) is structure membership operator (member access operator, member operator)
	strcpy(genie.name, "Will Smith");
	//strncpy(genie.name, "Will Smith", MAX);
	//genie.name = "Will Smith";  // C ì–¸ì–´ì—ì„œëŠ” ë¬¸ìì—´ì„ ëŒ€ì… ì—°ì‚°ì(=)ë¡œ ì§ì ‘ í• ë‹¹í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
	genie.age = 1000;

	// dot(.) has higher precedence than &
	flag = scanf("%f", &genie.height);//&(genie.height)
	printf("%f\n", genie.height);



	/* Initialization */
	struct person princess = { "Naomi Scott", 18, 160.0f };

	struct person princess2 = {
		"Naomi Scott",
		18,
		160.0f
	};

	strcpy(princess.name, "Naomi Scott");
	princess.age = 18;
	princess.height = 160.0f;



	/*  Designated initializers */
	struct person beauty = {
		.age = 19,
		.name = "Bell",
		.height = 150.0f
	};
	//struct person beauty = { .age = 19, .name = "Bell", .height = 150.0f };



	/* Pointer to a strcture variable */
	struct person* someone;

	someone = &genie;
	//someone = (struct Person*)malloc(sizeof(struct Person)); // and free later



	/* Indirect member(ship) operator (or structure pointer operator) */
	someone->age = 1001;// arrow(->) operator
	printf("%s %d\n", someone->name, (*someone).age);



	/* Structure declarations in a function */
	struct book
	{
		char title[MAX];
		float price;
	};



	/* No tag */  // ì ê¹ ì“°ê³  ë§ êµ¬ì¡°ì²´ë¼ë©´...
	struct
	{
		char farm[MAX];
		float price;
	} apple, apple2;

	strcpy(apple.farm, "Trade Joe");
	apple.price = 1.2f;

	strcpy(apple2.farm, "Safeway");
	apple2.price = 5.6f;



	/* typedef and structure */

	typedef struct person my_person;

	my_person p3;

	typedef struct person person;

	person p4;

	typedef struct {
		char name[MAX];
		char hobby[MAX];
	} friend;

	friend f4;

	return 0;
}
```


### ğŸ“Œ 14.3 êµ¬ì¡°ì²´ì˜ ë©”ëª¨ë¦¬ í• ë‹¹(Memory Allocation)
- PADDING.
``` c
#include <stdio.h>
#include <stdlib.h>

int main()
{
	/*
		Well aligned structure
	*/

	struct Aligned
	{
		int a;
		float b;
		double c;
	};

	/*
	 0 1 2 3 4 5 6 7|8 9 10 11 12 13 14 15|
	|int a  |float b|double c             |
	4 + 4 + 8 = 16
	*/



	struct Aligned a1, a2;

	printf("struct Aligned a1\n");
	printf("Sizeof %zd\n", sizeof(struct Aligned));	// Sizeof 16
	printf("%lld\n", (long long)&a1);				// 828852140520
	printf("%lld\n", (long long)&a1.a);				// 828852140520
	printf("%lld\n", (long long)&a1.b);				// 828852140524
	printf("%lld\n", (long long)&a1.c);				// 828852140528

	printf("\nstruct Aligned a2\n");
	printf("Sizeof %zd\n", sizeof(a2));		// Sizeof 16
	printf("%lld\n", (long long)&a2);		// 828852140568
	printf("%lld\n", (long long)&a2.a);		// 828852140568
	printf("%lld\n", (long long)&a2.b);		// 828852140572
	printf("%lld\n", (long long)&a2.c);		// 828852140576



	/*
		padding (struct member alignment)
		- 1 word: 4 bytes in x86, 8 bytes in x64
		          CPUì™€ ë©”ëª¨ë¦¬ê°€ ë°ì´í„°ë¥¼ ì£¼ê³ ë°›ì„ ë•Œ ì‚¬ìš©ë˜ëŠ” ê¸°ë³¸ ë‹¨ìœ„.
	*/

	struct Padded1
	{
		char a;
		float b;
		double c;
	};

	/* Without padding
	 0 1 2 3 4 5 6 7|8 9 10 11 12 13 14 15|16
	|a|float b|double c          | ?  ?  ?     <<- ë°ì´í„°ê°€ ì˜ë ¤ì„œ ë„ì°©í•¨.
	1 + 4 + 8 = 13
	*/

	/* With padding
	 0 1 2 3 4 5 6 7|8 9 10 11 12 13 14 15|16  <<-  char ë’¤ì— 3ìë¦¬ ë” íŒ¨ë”©.
	|char a |float b|double c             |
	4(char?) + 4 + 8 = 16
	*/

	struct Padded1 p1;

	printf("\nstruct Padded1 p1\n");
	printf("Sizeof %zd\n", sizeof(p1));		// Sizeof 16
	printf("%lld\n", (long long)&p1);		// 620863616296
	printf("%lld\n", (long long)&p1.a);		// 620863616296  <<-
	printf("%lld\n", (long long)&p1.b);		// 620863616300
	printf("%lld\n", (long long)&p1.c);		// 620863616304




	struct Padded2
	{
		float a;
		double b;
		char c;
	};

	/*
	|0 1 2 3 4 5 6 7|8 9 10 11 12 13 14 15|16 17 18 19 20 21 22 23|24
	|float a        | double b            | char c                |
	8(float?) + 8 + 8(char?) = 24

	doubleì„ ìë¥´ì§€ ì•Šìœ¼ë ¤ê³  floatì— +4 íŒ¨ë”©.
	*/

	struct Padded2 p2;

	printf("\nstruct Padded p2\n");
	printf("Sizeof %zd\n", sizeof(p2));		// Sizeof 24
	printf("%lld\n", (long long)&p2);		// 620863616344
	printf("%lld\n", (long long)&p2.a);		// 620863616344
	printf("%lld\n", (long long)&p2.b);		// 620863616352
	printf("%lld\n", (long long)&p2.c);		// 620863616360



	struct Padded3
	{
		char a;
		double b;
		double c;
	};

	/*
	|0 1 2 3 4 5 6 7|8 9 10 11 12 13 14 15|16 17 18 19 20 21 22 23|24
	| char a        | double b            | double c              |
	8(char?) + 8 + 8 = 24
	*/

	struct Padded3 p3;

	printf("\nstruct Padded2 p3\n");
	printf("Sizeof %zd\n", sizeof(p3));		// Sizeof 24
	printf("%lld\n", (long long)&p3);		// 620863616392
	printf("%lld\n", (long long)&p3.a);		// 620863616392
	printf("%lld\n", (long long)&p3.b);		// 620863616400
	printf("%lld\n", (long long)&p3.c);		// 620863616408
	


	struct Person
	{
		char name[41];	// member
		int age;		// member
		float height;	// member
	};

	struct Person mommy;

	printf("\nstruct Person\n");
	printf("%lld\n", (long long)&mommy.name[0]);
	printf("%lld\n", (long long)&mommy.age);
	printf("%lld\n", (long long)&mommy.height);
	printf("Sizeof %zd\n", sizeof(mommy));// 41 + 4 + 4 = 49 ?

	struct Person f[4];

	printf("Sizeof a structure array %zd\n", sizeof(f));
	/*
	|f[0].name        | f[0].age | f[0].height | ... ... |f[3].name        | f[3].age | f[3].height |
	*/

	return 0;
}
```


### ğŸ“Œ 14.4 êµ¬ì¡°ì²´ì˜ ë°°ì—´ ì—°ìŠµë¬¸ì œ
``` c
#include <stdio.h>
#include <string.h>

#define Max_title 50
#define Max_Library 3
#define Max_author 30

char* s_fgets(char* st, int n)
{
	char* pt;
	pt = fgets(st, n, stdin);

	if (pt)
	{
		char* find;
		if (find = strchr(pt, '\n'))
			*find = '\0';
		else
			while (getchar() != '\n');
	}

	return pt;
}

struct Book {
	char title[Max_title];
	char author[Max_author];
	float price;
};

int main()
{
	struct Book Library[3] = { {"None", "None", 0.0f}, };

	int count = 0;

	while (1)
	{
		printf("Input a book title or press [Enter] to stop.\n>>");
		if (s_fgets(Library[count].title, Max_title) == NULL)
			break;
		if (Library[count].title == '\0')
			break;

		printf("Input the author.\n>>");
		s_fgets(Library[count].author, Max_author);

		printf("Input the price.\n>>");
		int flag = scanf("%f", &Library[count].price);
		while (getchar() != '\n');

		count++;

		if (count == Max_Library)
			break;
	}

	for (int i = 0; i < count; ++i)
		printf("\"%s\" %s: $%.1f\n", Library[i].title, Library[i].author, Library[i].price);

	return 0;
}
```


### ğŸ“Œ 14.5 êµ¬ì¡°ì²´ë¥¼ ë‹¤ë¥¸ êµ¬ì¡°ì²´ì˜ ë©¤ë²„ë¡œ ì‚¬ìš©í•˜ê¸°(ì¤‘ì²© êµ¬ì¡°ì²´, Nested Structures)
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define LEN 20

struct names {			// A structure
	char given[LEN];	// first name
	char family[LEN];	// last name
};

struct reservation {	// Another structure
	struct names guest;	// a nested structure
	struct names host;  // one more nested structure
	char food[LEN];
	char place[LEN];

	// time
	int year;
	int month;
	int day;
	int hours;
	int minutes;
};

int main(void)
{
	struct reservation res = {
		.guest = {"Nick", "Carraway"},
		.host = {"Jay", "Gatsby"},
		.place = {"the Gatsby mansion"},
		.food = {"Escargot"},
		.year = 1925,
		.month = 4,
		.day = 10,
		.hours = 18,
		.minutes = 30
	};

	printf("Dear %s %s,\n", res.guest.given, res.guest.family);
	printf("I would like to serve you %s.\n", res.food);
	printf("Please visit %s on %d/%d/%d at %d:%d.\n",
		res.place, res.day, res.month, res.year, res.hours, res.minutes);
	printf("Sincerely,\n");
	printf("%s %s\n", res.host.given, res.host.family);

	/*
	Dear Nick Carraway,
	I would like to serve you Escargot.
	Please visit the Gatsby mansion on 10/4/1925 at 18:30.
	Sincerely,
	Jay Gatsby
	*/

	return 0;
}
```


### ğŸ“Œ 14.6 êµ¬ì¡°ì²´ì™€ í¬ì¸í„°
<img width="500" alt="image" src="https://github.com/user-attachments/assets/be447da9-37b6-404a-8723-60aea7c28e39" />

``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define LEN 20

struct names {
	char given[LEN];
	char family[LEN];
};

struct friend {
	struct names full_name;
	char mobile[LEN];
};

int main(void)
{
	struct friend my_friends[2] = {
		{ {"Ariana", "Grande"}, "1234-1234"	},
		{ {"Taylor", "Swift"}, "6550-8888" }
	};

	struct friend* girl_friend;

	girl_friend = &my_friends[0];

	printf("%zd\n", sizeof(struct friend));
	printf("%lld %s\n", (long long)girl_friend, girl_friend->full_name.given);
	// -> : indirect member access operator  <<- í¬ì¸í„°ì¼ ë•ŒëŠ”.

	girl_friend++;

	printf("%lld %s\n", (long long)girl_friend, (*girl_friend).full_name.given);
	// . has higher precedence than *

	return 0;
}
```
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

struct my_data
{
	int a;
	char c;
	float arr[2];
};

int main()
{
	struct my_data d1 = { 1234, 'A', };

	d1.arr[0] = 1.1f;
	d1.arr[1] = 2.2f;

	printf("%d %c %lld\n", d1.a, d1.c, (long long)d1.arr);
	printf("%f %f\n", d1.arr[0], d1.arr[1]);
	printf("%lld %lld\n\n", (long long)&d1.arr[0], (long long)&d1.arr[1]);

	struct my_data d2 = d1;  // ê°’ë“¤ì„ ë³µì‚¬.

	printf("%d %c %lld\n", d2.a, d2.c, (long long)d2.arr);
	printf("%f %f\n", d2.arr[0], d2.arr[1]);
	printf("%lld %lld\n", (long long)&d2.arr[0], (long long)&d2.arr[1]);

	return 0;
}
```
- ë°°ì—´ì€ êµ¬ì¡°ì²´ ë³µì‚¬ ì‹œ ë°°ì—´ì˜ ê°’ì´ ë³µì‚¬ë˜ê³ , ë©”ëª¨ë¦¬ ê³µê°„ì€ ë³„ë„ë¡œ í• ë‹¹ë©ë‹ˆë‹¤.
- í¬ì¸í„°ëŠ” êµ¬ì¡°ì²´ ë³µì‚¬ ì‹œ í¬ì¸í„°ê°€ ê°€ë¦¬í‚¤ëŠ” ë©”ëª¨ë¦¬ ì£¼ì†Œë§Œ ë³µì‚¬ë˜ë¯€ë¡œ, ë™ì  ë©”ëª¨ë¦¬ ì£¼ì†Œë¥¼ ê³µìœ í•˜ê²Œ ë˜ì–´,  
  ë‘ êµ¬ì¡°ì²´ì—ì„œ ê°™ì€ ë©”ëª¨ë¦¬ ê³µê°„ì„ ì°¸ì¡°í•©ë‹ˆë‹¤.  
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

struct my_data
{
	int a;
	char c;
	float* arr;
};

int main()
{
	struct my_data d1 = { 1234, 'A', NULL };
	d1.arr = (float*)malloc(sizeof(float) * 2);
	d1.arr[0] = 1.1f;
	d1.arr[1] = 2.2f;

	printf("%d %c %lld\n", d1.a, d1.c, (long long)d1.arr);
	printf("%f %f\n", d1.arr[0], d1.arr[1]);
	printf("%lld %lld\n\n", (long long)&d1.arr[0], (long long)&d1.arr[1]);

	struct my_data d2 = d1;  // ë™ì í• ë‹¹ì´ ìˆëŠ” êµ¬ì¡°ì²´ë¥¼ ë³µì‚¬í•˜ë©´, ì£¼ì†Œê¹Œì§€ ê°™ì´ ê³µìœ í•˜ê²Œ ëœë‹¤.

	printf("%d %c %lld\n", d2.a, d2.c, (long long)d2.arr);
	printf("%f %f\n", d2.arr[0], d2.arr[1]);
	printf("%lld %lld\n", (long long)&d2.arr[0], (long long)&d2.arr[1]);

	return 0;
}
```


### ğŸ“Œ 14.7 êµ¬ì¡°ì²´ë¥¼ í•¨ìˆ˜ë¡œ ì „ë‹¬í•˜ëŠ” ë°©ë²•
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#define FUNDLEN 50

struct fortune {
	char	bank_name[FUNDLEN];
	double	bank_saving;
	char	fund_name[FUNDLEN];
	double	fund_invest;

	float* arr;
};

double sum(struct fortune*);

int main()
{
	struct fortune my_fortune = {
		"Wells-Fargo",
		123.45,
		"JPMorgan Chase",
		6789.7
	};

	printf("Total : $%.2f.\n",
		//sum(&my_fortune.bank_saving, &my_fortune.fund_invest)
		sum(&my_fortune)
	);

	//struct fortune my_fortune2;
	//my_fortune2 = my_fortune;

	printf("%f", my_fortune.bank_saving);
	

	return 0;
}

double sum(struct fortune* mf)	//TOOD: try pointers
{
	//(*mf).bank_saving = 1.1;

	//return mf->bank_saving + mf->fund_invest;
	return (*mf).bank_saving + (*mf).fund_invest;
}
```


### ğŸ“Œ 14.8 êµ¬ì¡°ì²´ì™€ í•¨ìˆ˜ ì—°ìŠµë¬¸ì œ
- Q1.
- `scanf("%[^\n]%*c", pt_user_name->first);`ì—ì„œ `%*c`ê°€ í•„ìš”í•œ ì´ìœ ëŠ”  
  `ì…ë ¥ ë²„í¼ì— ë‚¨ì•„ ìˆëŠ” ì¤„ë°”ê¿ˆ ë¬¸ì(\n)ë¥¼ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ì„œ`ì…ë‹ˆë‹¤.
- C++ì—ì„œëŠ” êµ¬ì¡°ì²´ ì•ˆì— í•¨ìˆ˜(=ê¸°ëŠ¥)ë¥¼ ë„£ì–´ë²„ë¦°ë‹¤.
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define NLEN 30

struct name_count {
	char first[NLEN];
	char last[NLEN];
	int num;
};

void receive_input(struct name_count*);
void count_characters(struct name_count*);
void show_result(const struct name_count*);
char* s_gets(char* st, int n);

int main()
{
	struct name_count user_name;

	receive_input(&user_name);
	count_characters(&user_name);
	show_result(&user_name);

	return 0;
}



void receive_input(struct name_count* pt_user_name)
{
	//printf("Input your first name:\n>> ");
	//s_gets(pt_user_name->first, NLEN);
	//printf("Input your last name:\n>> ");
	//s_gets(pt_user_name->last, NLEN);
	
	int flag;

	printf("Input your first name:\n>> ");
	flag = scanf("%[^\n]%*c", pt_user_name->first);  // ^ : cap operator
	if (flag != 1)
		printf("Wrong input");

	printf("Input your last name:\n>> ");
	flag = scanf("%[^\n]%*c", pt_user_name->last);
	if (flag != 1)
		printf("Wrong input");
}

void count_characters(struct name_count* pt_user_name)
{
	pt_user_name->num = (int)strlen(pt_user_name->first) + (int)strlen(pt_user_name->last);
}

void show_result(const struct name_count* pt_user_name)
{
	printf("Hi, %s %s. Your name has %d characters.",
		(*pt_user_name).first, (*pt_user_name).last, (*pt_user_name).num);
}

char* s_gets(char* st, int n)
{
	char* pt;
	char* find;

	pt = fgets(st, n, stdin);
	if (pt)
	{
		if (find = strchr(st, '\n'))
			*find = '\0';
		else
			while (getchar() != '\n');
	}

	return pt;
}
```
- Q2.
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>

#define NLEN 30

struct name_count {
	char first[NLEN];
	char last[NLEN];
	int num;
};

struct name_count receive_input();
struct name_count count_characters(struct name_count);
void show_result(const struct name_count);

int main()
{
	struct name_count user_name;

	user_name = receive_input();
	user_name = count_characters(user_name);
	show_result(user_name);

	return 0;
}

struct name_count receive_input()
{
	struct name_count nc;
	int flag;

	printf("Input your first name:\n>> ");
	flag = scanf("%[^\n]%*c", nc.first);
	if (flag != 1)
		printf("wrong input.");

	printf("Input your last name:\n>> ");
	flag = scanf("%[^\n]%*c", nc.last);
	if (flag != 1)
		printf("wrong input.");

	return nc;
}

struct name_count count_characters(struct name_count nc)
{
	nc.num = (int)strlen(nc.first) + (int)strlen(nc.last);

	return nc;
}

void show_result(const struct name_count nc)
{
	printf("Hi, %s %s. Your name has %d characters.",
		nc.first, nc.last, nc.num);
}
```


### ğŸ“Œ 14.9 êµ¬ì¡°ì²´ì™€ í• ë‹¹ ë©”ëª¨ë¦¬
- ë™ì  í• ë‹¹ì„ ì¨ì•¼ í•˜ëŠ” ê²½ìš°, ì˜¬ë°”ë¥¸ ì‚¬ìš©ë²•  
  âœ” ì‚¬ìš©ìê°€ ì…ë ¥í•œ ê°€ë³€ ê¸¸ì´ ë¬¸ìì—´ì„ ì €ì¥í•´ì•¼ í•  ë•Œ  
  âœ” MAXTITL ê°™ì€ ê³ ì • í¬ê¸° ì œí•œ ì—†ì´ ë©”ëª¨ë¦¬ë¥¼ ìœ ì—°í•˜ê²Œ ê´€ë¦¬í•˜ê³  ì‹¶ì„ ë•Œ  
  âœ” ë§¤ìš° í° ë°ì´í„°ë¥¼ ë‹¤ë£° ë•Œ, ìŠ¤íƒ ëŒ€ì‹  í™ì— ì €ì¥í•˜ëŠ” ê²ƒì´ ìœ ë¦¬í•  ë•Œ  
``` c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct book {
    char* title;
    char* author;
    float price;
};

int main() {
    struct book myBook;

    // ë™ì  í• ë‹¹
    myBook.title = (char*)malloc(100);  // 100ë°”ì´íŠ¸ í¬ê¸° í• ë‹¹
    myBook.author = (char*)malloc(100); // 100ë°”ì´íŠ¸ í¬ê¸° í• ë‹¹

    if (myBook.title == NULL || myBook.author == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }

    // ë¬¸ìì—´ ë³µì‚¬
    strcpy(myBook.title, "The C Programming Language");
    strcpy(myBook.author, "Brian Kernighan, Dennis Ritchie");

    // ì¶œë ¥
    printf("Title: %s\n", myBook.title);
    printf("Author: %s\n", myBook.author);

    // í• ë‹¹ëœ ë©”ëª¨ë¦¬ í•´ì œ (ì•ˆ í•˜ë©´ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°œìƒ!)
    free(myBook.title);
    free(myBook.author);

    return 0;
}
```
<img width="600" alt="image" src="https://github.com/user-attachments/assets/2ceb2b98-9fa5-4a98-b060-73fdb27301e9" />


### ğŸ“Œ 14.10 ë³µí•© ë¦¬í„°ëŸ´(Compound Literal)
- book_to_read = `(struct book)`{ "Alice in Wonderland", "Lewis Carroll", 20.3f };
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#define MAXTITL 41
#define MAXAUTL 31

struct book
{
	char title[MAXTITL];
	char author[MAXAUTL];
	//char* title;		// Not recommended
	//char* author;		// Not recommended
	float price;
};

struct rectangle
{
	double width;
	double height;
};

double rect_area(struct rectangle r)
{
	return r.width * r.height;
}

double rect_area_ptr(struct rectangle* r)
{
	return r->width * r->height;
}

int main()
{
	struct book book_to_read = { "Crime and Punishment", "Fyodor Dostoyevsky", 11.25f };

	/*
		Compound literals
		- Temporary structure values
	*/

	// êµ¬ì¡°ì²´ ìì²´ë¥¼ ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸ë¡œ ë®ì–´ì“¸ ìˆ˜ ì—†ëŠ” ì´ìœ ëŠ”,
	// êµ¬ì¡°ì²´ ì„ ì–¸ ì‹œì— ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸ê°€ ì‚¬ìš©ë˜ê¸° ë•Œë¬¸ì´ë©°,
	// ì„ ì–¸ í›„ì—ëŠ” ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸ë¡œ ë®ì–´ì“°ëŠ” ë¬¸ë²•ì´ Cì—ì„œ í—ˆìš©ë˜ì§€ ì•Šê¸° ë•Œë¬¸
	// ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸ëŠ” ë³€ìˆ˜ ì„ ì–¸ê³¼ ë™ì‹œì— ì´ˆê¸°ê°’ì„ í• ë‹¹í•  ë•Œë§Œ ì‚¬ìš©ë¨.
	//book_to_read = { "Alice in Wonderland", "Lewis Carroll", 20.3f };//Error

	// memberë³„ë¡œ ìˆ˜ì •í•˜ëŠ” ë°©ë²•
	strcpy(book_to_read.title, "Alice in Wonderland");
	strcpy(book_to_read.author, "Lewis Carroll");
	book_to_read.price = 20.3f;

	// temp êµ¬ì¡°ì²´ë¥¼ ë§Œë“¤ì–´ì„œ ë³µì‚¬í•˜ëŠ” ë°©ë²•
	struct book book2 = { "Alice in Wonderland", "Lewis Carroll", 20.3f };
	book_to_read = book2;

	// Compound Literal !
	book_to_read = (struct book){ "Alice in Wonderland", "Lewis Carroll", 20.3f };  // l-value

	printf("%s %s\n", book_to_read.title, book_to_read.author);


	
	// l-value íŠ¹ì„± í™•ì¸.
	struct rectangle rec1 = { 1.0, 2.0 };
	double area = rect_area(rec1);
	area = rect_area((struct rectangle) { 1.0, 2.0 });  // ê³„ì‚°ë§Œ í•„ìš”ë¡œ í• ë•ŒëŠ” êµ¬ì¡°ì²´ì˜ ë³€ìˆ˜ ì„ ì–¸ ì—†ì´ ì´ë ‡ê²Œ.

	area = rect_area_ptr(&(struct rectangle) { .height = 3.0, .width = 2.0 });// Designated initializers
	printf("%f\n", area);

	return 0;
}
```


### ğŸ“Œ 14.11 ì‹ ì¶•ì„±ìˆëŠ” ë°°ì—´ ë©¤ë²„(Flexible Array Members)
<img width="500" alt="image" src="https://github.com/user-attachments/assets/871516c7-9341-46c3-b913-2c1fb4ccbe9f" />
<img width="500" alt="image" src="https://github.com/user-attachments/assets/e1651afb-6432-4eb0-878d-8fac9e01da53" />
- ê²°ë¡  : ë°°ì—´ í¬ê¸°ë¥¼ ë™ì ìœ¼ë¡œ ë³€ê²½í•´ì•¼ í•˜ëŠ” ê²½ìš°ë‚˜ êµ¬ì¡°ì²´ ë‚´ ì—¬ëŸ¬ ë©¤ë²„ê°€ ì—°ì†ëœ ë©”ëª¨ë¦¬ ë¸”ë¡ì— ì €ì¥ë˜ì–´ì•¼ í•  ë•ŒëŠ” êµ¬ì¡°ì²´ í¬ê¸° ë™ì  í• ë‹¹ ë°©ì‹ì´ ë” ì í•©í•©ë‹ˆë‹¤. ë°˜ë©´, ê° ë©¤ë²„ì— ë™ì  í• ë‹¹í•˜ëŠ” ë°©ì‹ì€ ê° ë©¤ë²„ë§ˆë‹¤ ë…ë¦½ì ìœ¼ë¡œ ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹í•˜ê³  ê´€ë¦¬í•  ìˆ˜ ìˆì–´ ìœ ì—°í•©ë‹ˆë‹¤.

``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

int main()
{
	/*
		Flexible array member (struct hack in GCC)
	*/

	struct flex
	{
		size_t count;
		double average;
		double values[];	// flexible array member (last member!)
	};

	const size_t n = 3;

	struct flex* pf = (struct flex*)malloc(sizeof(struct flex) + n * sizeof(double));
	if (pf == NULL) exit(1);

	printf("\nFlexible array member\n");
	printf("Sizeof struct flex %zd\n", sizeof(struct flex));	// 16
	printf("Sizeof *pf %zd\n", sizeof(*pf));	// 16
	printf("Sizeof malloc %zd\n", sizeof(struct flex) + n * sizeof(double));	// 40

	printf("%lld\n", (long long)pf);	// 12529848
	printf("%lld\n", (long long)&pf->count);	// 12529848
	printf("%zd\n", sizeof(pf->count));	// 4
	printf("%lld\n", (long long)&pf->average);	// 12529856  <- paddingìœ¼ë¡œ 8 ì°¨ì´ê°€ ë‚œë‹¤.
	printf("Address of pf->values %lld\n", (long long)&pf->values);	// 12529864
	printf("Value of pf->values %lld\n", (long long)pf->values);	// 12529864
	printf("Sizeof pf->values %zd\n", sizeof(pf->values));	// 0



	pf->count = n;
	pf->values[0] = 1.1;
	pf->values[1] = 2.1;
	pf->values[2] = 3.1;

	pf->average = 0.0;
	for (unsigned i = 0; i < pf->count; ++i)
		pf->average += pf->values[i];
	pf->average /= (double)pf->count;

	printf("Average = %f\n", pf->average);	// Average = 2.100000

	/*
	struct nonflex
	{
		size_t count;
		double average;
		double *values;		// Use malloc()           <<- í¬ì¸í„° ë©”ëª¨ë¦¬ê°€ ì¶”ê°€ë¡œ ë” ì‚¬ìš©ëœë‹¤.
	};

	struct nonflex nf;
	nf.value = (double*)malloc(sizeof(double) * n);   <<- ë©”ëª¨ë¦¬ ì–´ë””ì— ìœ„ì¹˜í•´ ìˆëŠ”ì§€ ì•Œ ìˆ˜ê°€ ì—†ë‹¤.
	*/

	/*
		struct flex* pf2 = (struct flex*)malloc(sizeof(struct flex) + n * sizeof(double));
		if (pf2 == NULL) exit(1);

		//16bytesë§Œ ë³µì‚¬í•´ì£¼ê³ , ë™ì í• ë‹¹ ë°›ì•„ì˜¨ 24bytesëŠ” compilerê°€ ë³µì‚¬í•´ì£¼ì§€ ì•ŠëŠ”ë‹¤. 
		*pf2 = *pf1;		// Don't copy flexible members, use memcpy() instead

		free(pf);
		free(pf2);
	*/

	return 0;
}
```


### ğŸ“Œ 14.12 ìµëª… êµ¬ì¡°ì²´ (Anonymous Structures)
- [what-are-the-benefits-of-unnamed-structs?](https://stackoverflow.com/questions/13376494/what-are-the-benefits-of-unnamed-structs-unions-in-c)
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

struct names
{
	char first[20];
	char last[20];
};

struct person
{
	int id;
	struct names name;	// nested structure member : ì¤‘ì²© êµ¬ì¡°ì²´ ë©¤ë²„
};

struct person2
{
	int id;
	struct { char first[20]; char last[20]; };  // anonymous structure (NO TAG !)
};

int main()
{
	struct person ted = { 123, {"Bill", "Gates"} };
	struct person ted3 = { 125, "Robert", "Hand" };  // ì´ê²ƒë„ ë˜ëŠ”ë°,

	puts(ted.name.first);  // dot operator
	puts(ted3.name.first);

	struct person2 ted2 = { 124, {"Steve", "wozniak"} };
	//struct person2 ted2 = { 124, "Steve", "wozniak" };// also works
	puts(ted2.first);

	return 0;
}
```


### ğŸ“Œ 14.13 êµ¬ì¡°ì²´ì˜ ë°°ì—´ì„ ì‚¬ìš©í•˜ëŠ” í•¨ìˆ˜
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#define SLEN 101

struct book
{
	char name[SLEN];
	char author[SLEN];
};

void print_books(const struct book books[], int n);



// 1
int main()
{
	struct book my_books[3];// = { {"The Great Gatsby", "F. Scott Fitzgerald"}, ... };

	my_books[0] = (struct book){ "The Great Gatsby", "F. Scott Fitzgerald" };
	my_books[1] = (struct book){ "Hamlet", "William Shakespeare" };
	my_books[2] = (struct book){ "The Odyssey", "Homer" };

	print_books(my_books, 3);

	return 0;
}

void print_books(const struct book books[], int n)
{
	for (int idx = 0; idx < n; idx++)
		printf("Book %d : \"%s\" written by \"%s\"\n",
			idx + 1, books[idx].name, books[idx].author);
}



// 2
void print_books(const struct book* books, int n);

int main()
{
	struct book* my_books = (struct book*)malloc(sizeof(struct book) * 3);

	if (!my_books) {
		printf("Malloc failed");
		exit(1);
	}

	my_books[0] = (struct book){ "The Great Gatsby", "F. Scott Fitzgerald" };
	my_books[1] = (struct book){ "Hamlet", "William Shakespeare" };
	my_books[2] = (struct book){ "The Odyssey", "Homer" };

	print_books(my_books, 3);

	return 0;
}

void print_books(const struct book* books, int n)
{
	for (int idx = 0; idx < n; idx++)
		printf("Book %d : \"%s\" written by \"%s\"\n", idx + 1, (*(books + idx)).name, (books + idx)->author);
}
```


### ğŸ“Œ 14.14 êµ¬ì¡°ì²´ íŒŒì¼ ì…ì¶œë ¥ ì—°ìŠµë¬¸ì œ
- Q1.
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#define SLEN 101

struct book
{
	char name[SLEN];
	char author[SLEN];
};

void print_books(const struct book* books, int n);
void write_books(const char* filename, const struct book* books, int n);
//struct book* read_books(const char* filename, int* n);
void read_books2(const char* filename, struct book** books_dptr, int* n);

int main()
{
	int temp;
	int n = 3;

	struct book* my_books = (struct book*)malloc(sizeof(struct book) * 3);

	if (!my_books) {
		printf("Malloc failed");
		exit(1);
	}

	my_books[0] = (struct book){ "The Great Gatsby", "F. Scott Fitzgerald" };
	my_books[1] = (struct book){ "Hamlet", "William Shakespeare" };
	my_books[2] = (struct book){ "The Odyssey", "Homer" };

	print_books(my_books, n);

	printf("\nWriting to a file.\n");
	write_books("books.txt", my_books, n);
	free(my_books);
	n = 0;
	printf("Done.\n");

	printf("\nPress any key to read data from a file.\n\n");
	temp = _getch();

	//my_books = read_books("books.txt", &n);
	read_books2("books.txt", &my_books, &n);
	print_books(my_books, n);
	free(my_books);
	n = 0;

	return 0;
}

void print_books(const struct book* books, int n)
{
	for (int idx = 0; idx < n; ++idx)
		printf("Book %d : \"%s\" written by \"%s\"\n", idx + 1, books[idx].name, books[idx].author);
}

void write_books(const char* filename, const struct book* books, int n)
{
	FILE* fp;
	fp = fopen(filename, "w");
	if (!fp) exit(1);
	fprintf(fp, "%d\n", n);
	for (int i = 0; i < n; ++i)
		fprintf(fp, "%s\n%s\n", books[i].name, books[i].author);
	fclose(fp);
}

struct book* read_books(const char* filename, int* n)
{
	FILE* fp;
	int flag;
	
	fp = fopen(filename, "r");
	if (!fp) exit(1);
	flag = fscanf(fp, "%d%*c", n);
	if (flag != 1)
		printf("n fscanf error");

	struct book* books = (struct book*)calloc(*n, sizeof(struct book));

	for (int i = 0; i < *n; ++i)
	{
		flag = fscanf(fp, "%[^\n]%*c%[^\n]%*c", books[i].name, books[i].author);
		if (flag != 1)
			printf("books[%d] fscanf error", i);
	}
	
	return books;
}

void read_books2(const char* filename, struct book** books_dptr, int* n)
{
	FILE* fp;
	int flag;
	
	fp = fopen(filename, "r");
	if (!fp) exit(1);
	flag = fscanf(fp, "%d%*c", n);
	if (flag != 1)
	{
		printf("n fscanf error");
		exit(1);
	}

	struct book* books = (struct book*)calloc(*n, sizeof(struct book));
		
	for (int i = 0; i < *n; ++i)
	{
		flag = fscanf(fp, "%[^\n]%*c%[^\n]%*c", books[i].name, books[i].author);
		if (flag != 2)
		{
			printf("books[%d] fscanf error\n", i);
			exit(1);
		}
	}
	fclose(fp);

	*books_dptr = books;
}
```
- Q2. Binary
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>

#define SLEN 101

struct book
{
	char name[SLEN];
	char author[SLEN];
};

void print_books(const struct book* books, int n);
void write_books(const char* filename, const struct book* books, int n);
void read_books2(const char* filename, struct book** books_dptr, int* n);

int main()
{
	int temp;
	int n = 3;

	struct book* my_books = (struct book*)malloc(sizeof(struct book) * n);

	if (!my_books) {
		printf("Malloc failed");
		exit(1);
	}

	my_books[0] = (struct book){ "The Great Gatsby", "F. Scott Fitzgerald" };
	my_books[1] = (struct book){ "Hamlet", "William Shakespeare" };
	my_books[2] = (struct book){ "The Odyssey", "Homer" };

	print_books(my_books, n);

	printf("\nWriting to a file.\n");
	write_books("books.dat", my_books, n);
	free(my_books);
	n = 0;
	printf("Done.\n");

	printf("\nPress any key to read data from a file.\n\n");
	temp = _getch();

	read_books2("books.dat", &my_books, &n);
	print_books(my_books, n);
	free(my_books);
	n = 0;

	return 0;
}

void print_books(const struct book* books, int n)
{
	for (int i = 0; i < n; ++i)
		printf("Book %d : \"%s\" written by \"%s\"\n",
			i + 1, books[i].name, books[i].author);
}

void write_books(const char* filename, const struct book* books, int n)
{
	FILE* file = fopen(filename, "wb");//Binary

	if (file == NULL) {
		fputs("Can't open file.", stderr);
		exit(1);
	}

	fwrite(&n, sizeof(n), 1, file);// number of books
	fwrite(books, sizeof(struct book), n, file);

	fclose(file);
}

void read_books2(const char* filename, struct book** books_dptr, int* n_ptr)//Note: double pointer
{
	FILE* file = fopen(filename, "rb");

	if (file == NULL) {
		fputs("Can't open file.", stderr);
		exit(1);
	}

	fread(n_ptr, sizeof(*n_ptr), 1, file);

	struct book* books = (struct book*)calloc(sizeof(struct book), *n_ptr);//Note: calloc()

	if (!books) {
		printf("Malloc() failed.");
		exit(1);
	}

	fread(books, sizeof(struct book), *n_ptr, file);

	fclose(file);

	*books_dptr = books;
}
```


### ğŸ“Œ 14.15 ê³µìš©ì²´ì˜ ì›ë¦¬
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main()
{
	/*
		Union <- ê³µìš©ì²´ (ë©”ëª¨ë¦¬ë¥¼ ê°™ì´ ì‚¬ìš©í•¨)
		- Store different data types in the same memory space
		- Structure vs Union
	*/

	union my_union {
		int		i;
		double	d;
		char	c;
	};

	union my_union uni;

	printf("%zd\n", sizeof(union my_union)); // 8  <- ê°€ì¥ í° ìë£Œí˜•ìœ¼ë¡œ ë°°ì •ë¨.
	printf("%lld\n", (long long)&uni);  // 134470433480
	printf("%lld %lld %lld\n", (long long)&uni.i, (long long)&uni.d, (long long)&uni.c);  // 134470433480 134470433480 134470433480

	union my_union save[10];

	printf("%zd\n", sizeof(save));  // 80

	/*
		Union of different types
	*/

	union my_union uni1;

	uni1.c = 'A';
	printf("%c %x %d\n", uni1.c, (int)uni1.c, uni1.i);  // A 41 -858993599
	// 0xCCCCCC41 = -858993599

	uni1.i = 0;
	uni1.c = 'A';
	printf("%c %x %d\n", uni1.c, (int)uni1.c, uni1.i);  // A 41 65
	// 0x00000041 = 65

	uni1.d = 1.2;
	printf("%d %f %d %c\n", uni1.i, uni1.d, (int)uni1.c, uni1.c);  // 858993459 1.200000 51 3
	// 33 33 33 33 33 33 f3 3f
	// 0x3ff3333333333333 = 1.19999999999999995559107901499E0
	// 0x33333333 = 858993459  (decimal)
	// 0x33 = 51 = '3'

	/*
		Initializing unions
	*/

	union my_union uni2 = uni1;			 // Copy another union
	union my_union uni3 = { 10 };		 // First element (member) only
	union my_union uni4 = { .c = 'A' }; // Designated initializer
	union my_union uni5 = { .d = 1.23, .i = 100 }; // Do NOT recommend

	printf("%d %f %c\n", uni5.i, uni5.d, uni5.c);  // 100 0.000000 d

	uni.i = 123;
	uni.d = 1.2;
	uni.c = 'k';

	printf("%d %f %c\n", uni.i, uni.d, uni.c);  // 858993515 1.200000 k

	union my_union* pu = &uni;	// Pointer to union
	int x = pu->i; // -> operator, same as x = fit.digit

	//uni.c = 'A';
	uni.d = 65.345;
	double real = 3.14 * uni.d;	// do NOT recommend

	return 0;
}
```


### ğŸ“Œ 14.16 ê³µìš©ì²´ì™€ êµ¬ì¡°ì²´ë¥¼ í•¨ê»˜ ì‚¬ìš©í•˜ê¸°
- ê°ê°ì˜ ì´ë¦„ì´ ë™ì¼í•œ ë©”ëª¨ë¦¬ ê³µê°„ì„ ì°¸ì¡°í•˜ë¯€ë¡œ, ì ‘ê·¼ ë°©ì‹ë§Œ ë‹¤ë¥¼ ë¿ ì‹¤ì œ ë°ì´í„°ëŠ” ë™ì¼  
  ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±ì´ ë§¤ìš° ë†’ì•„, ê°™ì€ ë°ì´í„°ë¥¼ ë‹¤ì–‘í•œ ë°©ì‹ìœ¼ë¡œ ë‹¤ë£¨ëŠ” ë° ìœ ìš©
<img width="500" alt="image" src="https://github.com/user-attachments/assets/572244af-4d64-4312-b60c-2fe43dd6d112" />
<img width="600" alt="image" src="https://github.com/user-attachments/assets/1c4064d3-e663-47fc-b93d-873b583c6667" />

``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/*
	Unions And Structures
*/

struct personal_owner {
	char rrn1[7];		//Resident Registration Number
	char rrn2[8];		//ex: 830422-1185600
};

struct company_owner {
	char crn1[4];		//Company Registration Number
	char crn2[3];		//ex: 111-22-33333
	char crn3[6];
};

union data {
	struct personal_owner	po;
	struct company_owner	co;
};

struct car_data {
	char model[15];
	int status; /* 0 = personal, 1 = company */
	union data ownerinfo;
};

void print_car(struct car_data car)
{
	printf("---------------------------------\n");
	printf("Car model : %s\n", car.model);

	if (car.status == 0) /* 0 = personal, 1 = company */
		printf("Personal owner : %s-%s\n",
			car.ownerinfo.po.rrn1, car.ownerinfo.po.rrn2);
	else
		printf("Company owner : %s-%s-%s\n",
			car.ownerinfo.co.crn1, car.ownerinfo.co.crn2, car.ownerinfo.co.crn3);
	printf("---------------------------------\n");
}

int main()
{
	struct car_data my_car = { .model = "Avante",.status = 0,.ownerinfo.po = {"830422", "1185600"} };
	struct car_data company_car = { .model = "Sonata",.status = 1,.ownerinfo.co = {"111", "22", "33333"} };

	print_car(my_car);
	print_car(company_car);

	return 0;
}
```


### ğŸ“Œ 14.17 ìµëª… ê³µìš©ì²´
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/*
	Unions And Structures
*/

struct personal_owner {
	char rrn1[7];		//Resident Registration Number
	char rrn2[8];		//ex: 830422-1185600
};

struct company_owner {
	char crn1[4];		//Company Registration Number
	char crn2[3];		//ex: 111-22-33333
	char crn3[6];
};

struct car_data {
	char model[15];
	int status; /* 0 = personal, 1 = company */
	union {
		struct personal_owner	po;
		struct company_owner	co;
	};
};

void print_car(struct car_data car)
{
	printf("---------------------------------\n");
	printf("Car model : %s\n", car.model);

	if (car.status == 0) /* 0 = personal, 1 = company */
		printf("Personal owner : %s-%s\n",
			car.po.rrn1, car.po.rrn2);
	else
		printf("Company owner : %s-%s-%s\n",
			car.co.crn1, car.co.crn2, car.co.crn3);
	printf("---------------------------------\n");
}

int main()
{
	struct car_data my_car = { .model = "Avante",.status = 0,.po = {"830422", "1185600"} };
	struct car_data company_car = { .model = "Sonata",.status = 1,.co = {"111", "22", "33333"} };

	print_car(my_car);
	print_car(company_car);

	return 0;
}
```


### ğŸ“Œ 14.18 ì—´ê±°í˜•(Enumerated Types)
- enum(ì—´ê±°í˜•, Enumeration)ì€ ê°œë°œìê°€ íŠ¹ì •í•œ ìƒìˆ˜ë“¤ì˜ ì§‘í•©ì„ ì •ì˜í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ìë£Œí˜•  
  ì¦‰, `ì˜ë¯¸ ìˆëŠ” ì´ë¦„ì„ ìˆ«ì ê°’ì— í• ë‹¹`í•  ìˆ˜ ìˆë„ë¡ í•´ì£¼ëŠ” ê¸°ëŠ¥  
  ex) yellowë¼ëŠ” ì´ë¦„ìœ¼ë¡œ 2ë¥¼ ì‚¬ìš©í•˜ê²Œ í•´ì¤€ ê²ƒ.
``` c
#include <stdio.h>

/** Motivation
int c = 0; // red:0, orange:1, yellow:2, green:3, ...
if (c == 0)
	printf("red");
else if(c == 1)
	printf("orange");
else if (c == 2)
	printf("yellow");
... ...
*/

/**
#define RED		1
#define ORANGE	2
#define YELLOW  3

int c = YELLOW;
if (c == YELLOW)
	printf("yellow");
*/

int main()
{
	/*
		Enumerated type
		- Symbolic names to represent integer constants
		- Improve readability and make it easy to maintain
		- enum-specifier (struct-specifier, union-specifier)

		Enumerators
		- The symbolic constants
	*/

	enum spectrum { red, orange, yellow, green, blue, violet };
	//				0    1       2       3      4     5

	enum spectrum color;
	color = yellow;
	if (color == yellow)
		printf("yellow");	//Note: enumerators are not strings

	for (color = red; color <= violet; color++)//Note: ++ operator doesn't allowed in C++, use type int.
		printf("%d\n", color);

	printf("red = %d, orange = %d\n", red, orange);

	enum kids { jackjack, dash, snoopy, nano, pitz };
	// nina has a value of 3
	enum kids my_kid = nano;
	printf("nano %d %d\n", my_kid, nano);

	enum levels { low = 300, medium = 500, high = 2000 };

	int score = 800;//TODO: user input
	if (score > high)
		printf("High score!\n");
	else if (score > medium)
		printf("Good job\n");
	else if (score > low)
		printf("Not bad\n");
	else
		printf("Do your best\n");

	enum pet { cat, dog = 10, lion, tiger };
	// puma has a value of 11
	printf("cat %d\n", cat);
	printf("lion %d\n", lion);

	return 0;
}
```


### ğŸ“Œ 14.19 ì—´ê±°í˜• ì—°ìŠµë¬¸ì œ
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h> // strcmp (HINT!)
#include <stdbool.h>// C99

enum spectrum {red, orange, yellow, green, blue};
const char* colors[] = { "red", "orange", "yellow", "green", "blue"};

#define LEN 30

int main()
{
	char choice[LEN] = { 0, };
	enum spectrum color;
	bool color_is_found = false;
	
	while (1)
	{
		puts("Input a color name (empty line to quit):");

		if (scanf("%[^\n]%*c", choice) != 1)
			break;

		for (color = red; color <= blue; color++)
		{
			if (strcmp(choice, colors[color]) == 0)
			{
				color_is_found = true;
				break;
			}
		}

		if (color_is_found)
			switch (color)
			{
			case red:
				puts("Red roses");
				break;
			case orange:
				puts("Oranges are delicious");
				break;
			case yellow:
				puts("Yellow sunflowers");
				break;
			case green:
				puts("Green apples");
				break;
			case blue:
				puts("Blue ocean");
				break;
			}
		else
			printf("Please try different color %s.\n", choice);

		color_is_found = false;		
	}
	puts("Goodbye!");

	return 0;
}
```


### ğŸ“Œ 14.20 ì´ë¦„ê³µê°„ ê³µìœ í•˜ê¸°(Namespace)
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int iamfunction()
{
	return 0;
}

//int a = 123;

int main()
{
	/*
		namespace
		- Identify parts of a program in which a name is recognized
		- You can use the same name for one variable and one tag.
		- C++: use 'namespace' to use the same identifiers in the duplicated scopes.
	*/

	int myname = 123;

	{
		int myname = 345;
		//double myname = 3.14;//ERROR
	}

	struct rect { double x; double y; };

	//int rect = 123;	// OK in C (Not OK in C++)
	//struct rect rect = { 1.1, 2.2 };// struct rect and rect are in different categories

	typedef struct rect rect;
	rect rect = { 1.1, 2.2 };//Not OK

	//int iamfunction = iamfunction();//ERROR

	/*
		Namespace pollution (KNK p.465)
		- Names in different files accidentally conflicting with each other
	*/

	printf("%d\n", a);// other.c

	return 0;
}

//// other.c
int a = 1;
//static int a = 1;
int b = 2;
int c = 3;
int i = 4;
int j = 5;
int health = 100;
// more useful names
```


### ğŸ“Œ 14.21 í•¨ìˆ˜ í¬ì¸í„°ì˜ ì›ë¦¬(Function Pointers)
<img width="400" alt="image" src="https://github.com/user-attachments/assets/1a436d83-2b63-4dc7-8387-bdec3ca0842b" />
<img width="700" alt="image" src="https://github.com/user-attachments/assets/6d6a5369-c85e-4462-9f10-a4746ef30d25" />
<img width="400" alt="image" src="https://github.com/user-attachments/assets/471d32db-ac64-422d-93b6-3f3ff9435b07" />


### ğŸ“Œ 14.22 í•¨ìˆ˜ í¬ì¸í„°ì˜ ì‚¬ìš© ë°©ë²•(Function Pointers)
<img width="500" alt="image" src="https://github.com/user-attachments/assets/4da48611-5a8e-4eaa-819d-8d9ca79ea0dd" />

``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <ctype.h> // toupper(), tolower()

void ToUpper(char* str)
{
	while (*str)
	{
		*str = toupper(*str);
		str++;
	}
}

void ToLower(char* str)
{
	while (*str)
	{
		*str = tolower(*str);  // _cdecl í•¨ìˆ˜í˜¸ì¶œê·œì•½(?)
		str++;
	}
}

void UpdateString(char* str, int (*pf)(int))
{
	while (*str)
	{
		*str = (*pf)(*str);
		str++;
	}
}

int main()
{
	char str[] = "Hello, World!";

	void (*pf)(char*);  // í¬ì¸í„°ë¡œë§Œ ì‹¤í–‰ì‹œí‚¤ê¸° ìœ„í•´ì„œ, íŒŒë¼ë¯¸í„°ì˜ ì‚¬ì´ì¦ˆì™€ ë°˜í™˜ê°’ì˜ í˜•íƒœë¥¼ ë¯¸ë¦¬ ì ì–´ì¤˜ì•¼í•œë‹¤.

	pf = ToUpper;           // í•¨ìˆ˜ ì´ë¦„ ìì²´ê°€ ì£¼ì†Œë¥¼ ê°€ë¦¬í‚¨ë‹¤.
	// pf = &ToUpper;       // ì£¼ì†Œë¥¼ ì§ì ‘ ì°ì–´ì¤€ë‹¤.
	// pf = ToUpper(str);    <- ë°˜í™˜ê°’ì„ ë„£ê² ë‹¤ëŠ” ê±°ë‹ˆê¹Œ ì•ˆëœë‹¤.

	printf("String literal %lld\n", (long long)("Hello, World!"));	// String literal 9468720 (text segment)
	printf("Function pointer %lld\n", (long long)ToUpper);			// Function pointer 9442460 (text segment)
	printf("Variable %lld\n", (long long)str);						// Variable 16448984 (stack)

	(*pf)(str);  // í¬ì¸í„°ë‹ˆê¹Œ indirection í›„ ì‚¬ìš©í•œë‹¤. (ê¶Œì¥)
	//pf(str);   // ì£¼ì†Œ ìì²´ë„ í•¨ìˆ˜ëª…ì´ë‹ˆê¹Œ ê·¸ëƒ¥ ë°”ë¡œ ì“´ë‹¤.

	printf("ToUpper %s\n", str);		// ToUpper HELLO, WORLD!

	pf = ToLower;

	pf(str);

	printf("ToLower %s\n", str);		// ToLower hello, world!



	/*
		passing function pointers to functions
		- ê³µí†µëœ íŒ¨í„´(í•¨ìˆ˜)ë“¤ì„ ë¬¶ì–´ì„œ í•˜ë‚˜ì˜ í•¨ìˆ˜ë¡œ ë‹¤ì‹œ ë§Œë“¤ ìˆ˜ëŠ” ì—†ì„ê¹Œ.
		- 
	*/

	UpdateString(str, toupper);

	printf("ToUpper %s\n", str);		// ToUpper HELLO, WORLD!

	UpdateString(str, tolower);

	printf("ToLower %s\n", str);		// ToLower hello, world!

	//Note: __cdecl is function calling convention

	return 0;
}
```


### ğŸ“Œ 14.23 ìë£Œí˜•ì—ê²Œ ë³„ëª…ì„ ë¶™ì—¬ì£¼ëŠ” typedef
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <time.h>	// time()

int main()
{
	/*
	 (ìë£Œí˜•)(ì •ì˜)
		typedef specifier
		- Give symbolic names (or aliases) to types
		  (ìë£Œí˜•ì—ê²Œ ë˜ ë‹¤ë¥¸ ì´ë¦„, ë³„ëª…ì„ ë¶™í˜€ì£¼ëŠ” ê²ƒ)
		- Does not create new types.
		  (ìƒˆë¡œìš´ ìë£Œí˜•ì„ ë§Œë“œëŠ”ê±´ ì•„ë‹˜)
	*/

	typedef unsigned char BYTE;//Note the scope of BYTE

	BYTE x, y[10] = { 0, }, * z = &x;

	{
		typedef unsigned char byte;//You can use lowercases as well.

		/* Portable data types */

		size_t s = sizeof(byte);// unsigned int (x86), unsigned long long (x64)
		// unsigned int s = sizeof(byte);// x86 
		// unsigned long long s = sizeof(byte);//x64
	}

	//byte b;// typedef definition has a scope



	/*
		This function returns the time since 00:00:00 UTC, January 1, 1970 (Unix timestamp)
		in seconds.
	*/

	time_t t = time(NULL);

	printf("%lld\n", t);



	/*
		typedef vs #define
	*/

	typedef char* STRING;

	STRING name = "John Wick", sign = "World";

	/*
	- typedefëŠ” compilerê°€ ì²˜ë¦¬ë¥¼ í•´ì¤€ë‹¤. defineì€ ë‹¨ìˆœíˆ ë³µì‚¬ ë¶™í˜€ë„£ê¸°.

	- typedef interpretation is performed by the compiler, not the preprocessor
	- More flexible than #define

	#define STRING char *

	STRING name, sign;
	char * name, sign;//Note the type of sign
	*/

	typedef struct complex {
		float real;
		float imag;
	} COMPLEX;// typedef struct complex COMPLEX

	typedef struct { double width; double height; } rect;// No tag
	rect r1 = { 1.1, 2.2 };
	rect r2 = r1;
	printf("%f %f\n", r2.width, r2.height);

	return 0;
}



#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/*
    - ë³µì¡í•œ ì„ ì–¸ì€ typedefë¡œ ì˜ê²Œ ìª¼ê°œì„œ ë³´ë©´ í¸í•˜ë‹¤.

	"One good way to synthesize declarations is
	in small steps with typedef, ..."
	- K&R book Chapter 5.12
*/

/* Complicated Function Declarations */

char char3[3] = { 'A', 'B', 'C' };

char(*complicated_function1())[3] // Function Returns Pointer To Char[3]
{
	return &char3;// Returns a pointer to char[3]
}

typedef char(*FRPTC3())[3];	// Funciton Returns Pointer To Char[3]
typedef char(*(*PTFRPTC3)())[3];

char(*(*fptr1)())[3] = complicated_function1;

FRPTC3* fptr2 = complicated_function1;
PTFRPTC3 fptr3 = complicated_function1;

/* Use typedef to make declarations simpler */

typedef char c3[3];  // charì˜ 3ê°œì§œë¦¬ ë°°ì—´ì„ c3 ìë£Œí˜•ìœ¼ë¡œ ì„ ì–¸.

c3* complicated_function2()
{
	return &char3;// Returns a pointer to char[3]
}

int main()
{
	char(*ret_val)[3] = fptr1();

	printf("%c %c %c\n", (*ret_val)[0], (*ret_val)[1], (*ret_val)[2]);

	c3* my_c3 = fptr2();

	printf("%c %c %c\n", (*my_c3)[0], (*my_c3)[1], (*my_c3)[2]);

	return 0;
}
```


### ğŸ“Œ 14.24 ë³µì¡í•œ ì„ ì–¸ì„ í•´ì„í•˜ëŠ” ìš”ë ¹
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int temp(int a)
{
	return 0;
}

int (*g(int a))(int)
{
	return temp;
}

int main()
{
	/*
		*	indicates a pointer
		()	indicates a function
		[]	indicates an array
	*/

	/** Deciphering Complex Declarations (KNK 18.4)
		- ì•ˆìª½ì—ì„œ ë°”ê¹¥ìª½ìœ¼ë¡œ ì½ì–´ë¼.
		- *ë³´ë‹¤ (), []ê°€ ë” ë†’ë‹¤.

		- Always read declarations from the inside out.
		- When there's a choice, always favor [] and () over *(asterisk).
	*/


	// ë°°ì—´
	int* ap[10];	 // 10ê°œì§œë¦¬ ë°°ì—´, intí¬ì¸í„°ê°€ ë“¤ì–´ìˆëŠ”.    Identifier ap is an array of pointers

	typedef int* pint;
	pint ap2[10];


	// í•¨ìˆ˜
	float* fp(float);  // í•¨ìˆ˜ fp, floatì´ ë“¤ì–´ê°€ê³ , floatí¬ì¸í„°ê°€ return.    fp is a function that returns a pointer

	typedef float* pfloat;
	pfloat fp2(float);


	// ì •ìˆ˜í˜• ì¸ìë¥¼ ë°›ì•„ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜ì˜ ì£¼ì†Œë¥¼ ì €ì¥í•˜ëŠ” í¬ì¸í„°
	void (*pf)(int);  // í•¨ìˆ˜ì— ëŒ€í•œ í¬ì¸í„°ì¸ë°, intê°€ ë“¤ì–´ê°€ê³ , returnì´ ì—†ëŠ”.
	/*
		void (*pf)(int);
			  1           1. pointer to
					2     2. function with int argument
		 3                3. returning void
	*/

	// ë’¤ì— ê´„í˜¸ë©´ ì¸ì‹ìëŠ” í•¨ìˆ˜ë‹¤.
	int* (*x[10])(void);  // 10ê°œì§œë¦¬ ë°°ì—´ / í•¨ìˆ˜ì¸ë°, ë§¤ê°œë³€ìˆ˜ ì—†ì´, returnì´ int í¬ì¸í„°ì¸.
	/*
		int* (*x[10])(void);
				 1            1. array of
			  2               2. pointers to
						3     3. functions with no arguments
		 4                    4. returning pointer to int
	*/

	/* A function can't return an array */

	//int f(int)[]; // Wrong

	/* BUT it can return a pointer to an array */

	int(*f(int))[];

	/* A function can't return a function */

	//int g(int)(int); // Wrong

	/* BUT it can return a pointer to a function */

	int (*g(int))(int);

	/* An array of functions aren't possible */

	//int a[10](int); // Wrong

	/* BUT an array of function pointers are possible */

	int (*x2[10])(int);

	/* Using typedef to simplify declarations */

	typedef int FCN(int);
	typedef FCN* FCN_PTR;
	typedef FCN_PTR FCN_PTR_ARRAY[10];
	FCN_PTR_ARRAY x3;

	/* More examples */

	int board[6][4];// 6Ã—4 ë°°ì—´ (2ì°¨ì› ë°°ì—´)
	int** ptr;		// intë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ì˜ í¬ì¸í„°

	int* risks[10];	// ì •ìˆ˜ë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ë¥¼ ì €ì¥í•˜ëŠ” ë°°ì—´
	int(*rusk)[10];	// int[10]ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°

	int* off[3][4]; // 3x4 ë°°ì—´, ìš”ì†ŒëŠ” int* (í¬ì¸í„° ë°°ì—´)
	int(*uff)[3][4];// 3x4 ë°°ì—´ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°
	int(*uof[3])[4];// í¬ê¸° 3ì˜ ë°°ì—´, ìš”ì†ŒëŠ” int[4]ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°

	char* fump(int);// function returning pointer to char
	char (*frump)(int);// pointer to a function that returns type char
	char (*flump[3])(int);// array of 3 pointers to functions that return type char

	typedef int arr5[5];
	typedef arr5* p_arr5;
	typedef p_arr5 arrp10[10];

	arr5 togs;
	p_arr5 p2;
	arrp10 arp;

	return 0;
}
```


### ğŸ“Œ 14.25 qsort í•¨ìˆ˜ í¬ì¸í„° ì—°ìŠµë¬¸ì œ (quick sort)
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

//TODO: try increasing/decreasing order
int compare(const void* first, const void* second)
{
	if (*(float*)first > *(float*)second)
		return 1;
	else if (*(float*)first < *(float*)second)
		return -1;
	else
		return 0;
}

int main()
{
	float arr[] = { 8.1f, 2.4f, 5.6f, 3.2f, 6.1f, 11.0f };
	int n = sizeof(arr) / sizeof(arr[0]);

	qsort(arr, n, sizeof(float), compare);

	for (int i = 0; i < n; i++)
		printf("%f ", arr[i]);

	return 0;
}
```
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

struct kid
{
	char name[100];
	int height;
};

//TODO: try increasing/decreasing order
int compare(const void* first, const void* second);

int main()
{
	struct kid my_friends[] = {
		"Jack Jack", 40, "Geenie", 300, "Aladdin", 170, "Piona", 150
	};

	const int n = sizeof(my_friends) / sizeof(struct kid);

	qsort(my_friends, n, sizeof(struct kid), compare);

	for (int i = 0; i < n; i++)
		printf("%s     \t%d\n", my_friends[i].name, my_friends[i].height);

	return 0;
}

int compare(const void* first, const void* second)
{
	if (((struct kid*)first)->height > ((struct kid*)second)->height)
		return 1;
	else if (((struct kid*)first)->height < ((struct kid*)second)->height)
		return -1;
	else
		return 0;
}
```


### ğŸ“Œ 14.26 í•¨ìˆ˜ í¬ì¸í„°ì˜ ë°°ì—´ ì—°ìŠµë¬¸ì œ






















