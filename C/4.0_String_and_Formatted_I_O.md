### 📌 4.1 문자열 입출력하기
- %c -> %s(string으로 변경)
- 일반적인 char fruit_name이었으면, &fruit_name으로 주소를 가져왔겠지만,  
	fruit_name[40]은 char type 40개 메모리 공간을 대표하는 주소가 되어버리기 때문에 &(ampersand) 삭제

	> C에서 배열의 이름(변수명) 자체가 배열의 첫 번째 요소의 주소를 의미
``` c
#include <stdio.h>

int main()
{
	// 글자 하나만 담을 수 있고 문자열은 담을 수 없어서 (truncation)
	// char fruit_name[];
	char fruit_name[40];  // 배열로 변경(char type의 40byte를 확보)

	printf("What's your favorite fruit?\n");
	scanf("%s", fruit_name); //ampersand -> 주소로 넣기. / %s : string
	printf("oh, %s!\n", fruit_name);  //format(conversion) specifier

	return 0;
}
```


### 📌 4.2 sizeof()
1. sizeof basic types
- 자료형이 차지하는 메모리의 크기 확인 가능 / 함수가 아니라 연산자.
  기본적으로 unsigned int로 해결이 가능.(-1개는 아니니까.)
- size_t : portable type  
  sizeof가 알려주는 사이즈가 unsigned int가 아닐 수도 있어서 size_t를 사용 (이식성)
``` c
#include <stdio.h>
#include <stdlib.h> // malloc()

int main()
{
	int a = 0;
	unsigned int int_size1 = sizeof a;  // space 입력
	unsigned int int_size2 = sizeof(int);  // 자료형 직접 입력
	unsigned int int_size3 = sizeof(a);  // 변수

	size_t int_size4 = sizeof(a);
	size_t float_size = sizeof(float);
}
```
2. sizeof arrays
- int 타입의 30개 요소를 저장할 수 있는 배열 int_arr를 선언한다.
  (extern이 없는 경우, 선언 = 정의 의미 동일)
  - int_arr는 배열 전체의 크기를 알고 있음  
  - int_ptr은 그냥 포인터일 뿐, 배열의 크기를 모름
  <img width="500" src="https://github.com/user-attachments/assets/27ef9513-b8c7-4345-ad34-d61518d1cd9a"/>
``` c
	int  int_arr[30]; // int_arr[0] = 1024; ...
	int *int_ptr = NULL;
	int_ptr = (int*)malloc(sizeof(int) * 30); // int_ptr[0] = 1024; ...

	printf("Size of array = %zu bytes\n", sizeof(int_arr));  // 120 byte
	printf("Size of pointer = %zu bytes\n", sizeof(int_ptr));
```

3. sizeof character array
-  char만 maximally 9 character + '/0' (null character)
``` c
	char c = 'a';  // save 97 about ASCII code
	char string[10]; // maximally 9 character + '/0' (null character)

	size_t char_size = sizeof(char);
	size_t str_size = sizeof(string);

	printf("Size of char type is %zu bytes.\n", char_size);  // 1
	printf("Size of string type is %zu bytes.\n", str_size);  // 10
```

4. sizeof structure (구조체)
``` c
struct MyStruct
{
	int i;
	float f;
};

int main()
{
    printf("%zu\n", sizeof(struct MyStruct));  // 8 = int(4byte) + float(4byte)
}
```


### 📌 4.3 문자열이 메모리에 저장되는 구조
- 
``` c
#include <stdio.h>

int main()
{
	// 숫자의 배열
	int a = 1;
	int int_arr[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

	printf("%i %i %i\n", int_arr[0], int_arr[1], int_arr[9]);
	// index 초과 -> 정의되지 않은 동작(Undefined Behavior)
	printf("%i\n", int_arr[10000]);  // (process 18660) exited with code..

	// 문자의 배열
	char c = 'a';
	char str1[10] = "Hello";  // null character
	char str2[10] = { 'H', 'i' };

	printf("%c\n", c);  // a
	printf("%s\n", str1);  // Hello
	printf("%s\n", str2);  // Hi
	printf("%hhi %hhi %hhi\n", str2[0], str2[1], str2[2]);  // H i 0(\0, null)

	char str3[10] = "Hello, World";  // array bounds overflow  (13글자를 10byte에.)
	char str3[20] = "Hello, \0World";  // 메모리에는 있지만, null(\0)을 만나서 뒤의 World는 미출력.
	printf("%s\n", str3);  // Hello, 
	printf("%c\n", str3[10]);  // r

	return 0;
}
```


### 📌 4.4 strlen() 함수

