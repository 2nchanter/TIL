### 📌 4.1 문자열 입출력하기
- %c -> %s(string으로 변경)
- 일반적인 char fruit_name이었으면, &fruit_name으로 주소를 가져왔겠지만,  
	fruit_name[40]은 char type 40개 메모리 공간을 대표하는 주소가 되어버리기 때문에 &(ampersand) 삭제

	> C에서 배열의 이름(변수명) 자체가 배열의 첫 번째 요소의 주소를 의미
``` c
#include <stdio.h>

int main()
{
	// 글자 하나만 담을 수 있고 문자열은 담을 수 없어서 (truncation)
	// char fruit_name[];
	char fruit_name[40];  // 배열로 변경(char type의 40byte를 확보)

	printf("What's your favorite fruit?\n");
	scanf("%s", fruit_name); //ampersand -> 주소로 넣기. / %s : string
	printf("oh, %s!\n", fruit_name);  //format(conversion) specifier

	return 0;
}
```


### 📌 4.2 sizeof()
1. sizeof basic types
- 자료형이 차지하는 메모리의 크기 확인 가능 / 함수가 아니라 연산자.
  기본적으로 unsigned int로 해결이 가능.(-1개는 아니니까.)
- size_t : portable type  
  sizeof가 알려주는 사이즈가 unsigned int가 아닐 수도 있어서 size_t를 사용 (이식성)
``` c
#include <stdio.h>
#include <stdlib.h> // malloc()

int main()
{
	int a = 0;
	unsigned int int_size1 = sizeof a;  // space 입력
	unsigned int int_size2 = sizeof(int);  // 자료형 직접 입력
	unsigned int int_size3 = sizeof(a);  // 변수

	size_t int_size4 = sizeof(a);
	size_t float_size = sizeof(float);
}
```
2. sizeof arrays
- int 타입의 30개 요소를 저장할 수 있는 배열 int_arr를 선언한다.
  (extern이 없는 경우, 선언 = 정의 의미 동일)
  - int_arr는 배열 전체의 크기를 알고 있음  
  - int_ptr은 그냥 포인터일 뿐, 배열의 크기를 모름
  <img width="500" src="https://github.com/user-attachments/assets/27ef9513-b8c7-4345-ad34-d61518d1cd9a"/>
``` c
	int  int_arr[30]; // int_arr[0] = 1024; ...
	int *int_ptr = NULL;
	int_ptr = (int*)malloc(sizeof(int) * 30); // int_ptr[0] = 1024; ...

	printf("Size of array = %zu bytes\n", sizeof(int_arr));  // 120 byte
	printf("Size of pointer = %zu bytes\n", sizeof(int_ptr));
```

3. sizeof character array
-  char만 maximally 9 character + '/0' (null character)
``` c
	char c = 'a';  // save 97 about ASCII code
	char string[10]; // maximally 9 character + '/0' (null character)

	size_t char_size = sizeof(char);
	size_t str_size = sizeof(string);

	printf("Size of char type is %zu bytes.\n", char_size);  // 1
	printf("Size of string type is %zu bytes.\n", str_size);  // 10
```

4. sizeof structure (구조체)
``` c
struct MyStruct
{
	int i;
	float f;
};

int main()
{
    printf("%zu\n", sizeof(struct MyStruct));  // 8 = int(4byte) + float(4byte)
}
```


### 📌 4.3 문자열이 메모리에 저장되는 구조
``` c
#include <stdio.h>

int main()
{
	// 숫자의 배열
	int a = 1;
	int int_arr[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

	printf("%i %i %i\n", int_arr[0], int_arr[1], int_arr[9]);
	// index 초과 -> 정의되지 않은 동작(Undefined Behavior)
	printf("%i\n", int_arr[10000]);  // (process 18660) exited with code..

	// 문자의 배열
	char c = 'a';
	char str1[10] = "Hello";  // null character
	char str2[10] = { 'H', 'i' };

	printf("%c\n", c);  // a
	printf("%s\n", str1);  // Hello
	printf("%s\n", str2);  // Hi
	printf("%hhi %hhi %hhi\n", str2[0], str2[1], str2[2]);  // H i 0(\0, null)

	char str3[10] = "Hello, World";  // array bounds overflow  (13글자를 10byte에.)
	char str3[20] = "Hello, \0World";  // 메모리에는 있지만, null(\0)을 만나서 뒤의 World는 미출력.
	printf("%s\n", str3);  // Hello, 
	printf("%c\n", str3[10]);  // r

	return 0;
}
```


### 📌 4.4 strlen() 함수 (string length)
- strlen() 함수의 반환값은 size_t 타입이므로, 표준 format specifier가 %zu  
  null은 빼고, 실제 글자수만 count.
``` c
#include <stdio.h>
#include <string.h> // strlen and more
#include <stdlib.h>

int main()
{
	char str1[100] = "Hello";
	char str2[] = "Hello";  // 알아서 배열 설정
	char str3[100] = " \0";  // space도 count
	char str4[100] = "\n";  // line break(\n, escape sequence)도 count
	
	printf("%zu %zu\n", sizeof(str1), strlen(str1));  // 100 5
	printf("%zu %zu\n", sizeof(str2), strlen(str2));  // 6 5
	printf("%zu %zu\n", sizeof(str3), strlen(str3));  // 100 1
	printf("%zu %zu\n", sizeof(str4), strlen(str4));  // 100 1

	/* Extra */
	// str5라는 포인터가 100개의 char(문자)를 저장할 수 있도록 동적 메모리를 할당하는 과정
	char* str5 = (char*)malloc(sizeof(char) * 100);
	str5[0] = 'H'; str5[1] = 'e'; str5[2] = 'l'; str5[3] = 'l'; str5[4] = 'o';
	str5[5] = '\0';
	printf("%zu %zu\n", sizeof(str5), strlen(str5));  // 8 5 // 8 : 포인터 변수 자체의 사이즈

	return 0;
}
```
- memory allocation (메모리 할당)  
  malloc()(`동적 메모리 할당 함수`)을 호출하면 Heap 영역에서 100개의 char를 저장할 공간을 할당합니다. (sizeof(char) = 1)  
  malloc()의 반환값은 void 타입(제네릭 포인터)이라서, char*로 형 변환(casting)해야 합니다.  
  malloc()이 성공하면 `할당된 메모리의 시작 주소를 str5에 저장`합니다.  
  (str5는 char 타입을 가리키는 포인터 변수로, 문자열(또는 문자 배열)의 시작 주소를 저장할 수 있음)  
  이제 str5를 통해 `할당된 메모리에 접근`하여 `문자열을 저장`할 수 있습니다.


### 📌 4.5 기호적 상수와 전처리기
- 












