### 📌 4.1 문자열 입출력하기
- %c -> %s(string으로 변경)
- 일반적인 char fruit_name이었으면, &fruit_name으로 주소를 가져왔겠지만,  
	fruit_name[40]은 char type 40개 메모리 공간을 대표하는 주소가 되어버리기 때문에 &(ampersand) 삭제

	> C에서 배열의 이름(변수명) 자체가 배열의 첫 번째 요소의 주소를 의미
``` c
#include <stdio.h>

int main()
{
	// 글자 하나만 담을 수 있고 문자열은 담을 수 없어서 (truncation)
	// char fruit_name[];
	char fruit_name[40];  // 배열로 변경(char type의 40byte를 확보)

	printf("What's your favorite fruit?\n");
	scanf("%s", fruit_name); //ampersand -> 주소로 넣기. / %s : string
	printf("oh, %s!\n", fruit_name);  //format specifier

	return 0;
}
```


### 📌 4.2 sizeof()
1. sizeof basic types
- 자료형이 차지하는 메모리의 크기 확인 가능 / 함수가 아니라 연산자.  
  기본적으로 unsigned int로 해결이 가능.(-1개는 아니니까.)
- size_t : portable type  
  sizeof가 알려주는 사이즈가 unsigned int가 아닐 수도 있어서 size_t를 사용 (이식성)
``` c
#include <stdio.h>
#include <stdlib.h> // malloc()

int main()
{
	int a = 0;
	unsigned int int_size1 = sizeof a;  // space 입력
	unsigned int int_size2 = sizeof(int);  // 자료형 직접 입력
	unsigned int int_size3 = sizeof(a);  // 변수

	size_t int_size4 = sizeof(a);
	size_t float_size = sizeof(float);
}
```
2. sizeof arrays
- int 타입의 30개 요소를 저장할 수 있는 배열 int_arr를 선언한다.  
  (extern이 없는 경우, 선언 = 정의 의미 동일)  
  int_arr는 배열 전체의 크기를 알고 있음  
  int_ptr은 그냥 포인터일 뿐, 배열의 크기를 모름  
  <img width="500" src="https://github.com/user-attachments/assets/27ef9513-b8c7-4345-ad34-d61518d1cd9a"/>
``` c
	int  int_arr[30]; // int_arr[0] = 1024; ...
	int *int_ptr = NULL;
	int_ptr = (int*)malloc(sizeof(int) * 30); // int_ptr[0] = 1024; ...

	printf("Size of array = %zu bytes\n", sizeof(int_arr));  // 120 byte
	printf("Size of pointer = %zu bytes\n", sizeof(int_ptr));
```

3. sizeof character array
-  char만 maximally 9 character + '/0' (null character)
``` c
	char c = 'a';  // save 97 about ASCII code
	char string[10]; // maximally 9 character + '/0' (null character)

	size_t char_size = sizeof(char);
	size_t str_size = sizeof(string);

	printf("Size of char type is %zu bytes.\n", char_size);  // 1
	printf("Size of string type is %zu bytes.\n", str_size);  // 10
```

4. sizeof structure (구조체)
``` c
struct MyStruct
{
	int i;
	float f;
};

int main()
{
    printf("%zu\n", sizeof(struct MyStruct));  // 8 = int(4byte) + float(4byte)
}
```


### 📌 4.3 문자열이 메모리에 저장되는 구조
``` c
#include <stdio.h>

int main()
{
	// 숫자의 배열
	int a = 1;
	int int_arr[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

	printf("%i %i %i\n", int_arr[0], int_arr[1], int_arr[9]);
	// index 초과 -> 정의되지 않은 동작(Undefined Behavior)
	printf("%i\n", int_arr[10000]);  // (process 18660) exited with code..

	// 문자의 배열
	char c = 'a';
	char str1[10] = "Hello";  // null character
	char str2[10] = { 'H', 'i' };

	printf("%c\n", c);  // a
	printf("%s\n", str1);  // Hello
	printf("%s\n", str2);  // Hi
	printf("%hhi %hhi %hhi\n", str2[0], str2[1], str2[2]);  // H i 0(\0, null)

	char str3[10] = "Hello, World";  // array bounds overflow  (13글자를 10byte에.)
	char str3[20] = "Hello, \0World";  // 메모리에는 있지만, null(\0)을 만나서 뒤의 World는 미출력.
	printf("%s\n", str3);  // Hello, 
	printf("%c\n", str3[10]);  // r

	return 0;
}
```


### 📌 4.4 strlen() 함수 (string length)
- strlen() 함수의 반환값은 size_t 타입이므로, 표준 format specifier가 %zu  
  null은 빼고, 실제 글자수만 count.
``` c
#include <stdio.h>
#include <string.h> // strlen and more
#include <stdlib.h>

int main()
{
	char str1[100] = "Hello";
	char str2[] = "Hello";  // 알아서 배열 설정
	char str3[100] = " \0";  // space도 count
	char str4[100] = "\n";  // line break(\n, escape sequence)도 count
	
	printf("%zu %zu\n", sizeof(str1), strlen(str1));  // 100 5
	printf("%zu %zu\n", sizeof(str2), strlen(str2));  // 6 5
	printf("%zu %zu\n", sizeof(str3), strlen(str3));  // 100 1
	printf("%zu %zu\n", sizeof(str4), strlen(str4));  // 100 1

	/* Extra */
	// str5라는 포인터가 100개의 char(문자)를 저장할 수 있도록 동적 메모리를 할당하는 과정
	char* str5 = (char*)malloc(sizeof(char) * 100);
	str5[0] = 'H'; str5[1] = 'e'; str5[2] = 'l'; str5[3] = 'l'; str5[4] = 'o';
	str5[5] = '\0';
	printf("%zu %zu\n", sizeof(str5), strlen(str5));  // 8 5 // 8 : 포인터 변수 자체의 사이즈

	return 0;
}
```
- memory allocation (메모리 할당)  
  malloc()(`동적 메모리 할당 함수`)을 호출하면 Heap 영역에서 100개의 char를 저장할 공간을 할당합니다. (sizeof(char) = 1)  
  malloc()의 반환값은 void 타입(제네릭 포인터)이라서, char*로 형 변환(casting)해야 합니다.  
  malloc()이 성공하면 `할당된 메모리의 시작 주소를 str5에 저장`합니다.  
  (str5는 char 타입을 가리키는 포인터 변수로, 문자열(또는 문자 배열)의 시작 주소를 저장할 수 있음)  
  이제 str5를 통해 `할당된 메모리에 접근`하여 `문자열을 저장`할 수 있습니다.


### 📌 4.5 기호적 상수와 전처리기(Symbolic constant & #define)
- `#define PI 3.141592f` vs `const float PI = 3.141592f;`  
  일반적으로 const를 사용하는 것이 좋음.  
  #define은 단순 치환이라 타입 체크 불가능하고 디버깅이 어렵다.  
  const는 안전하고 유지보수하기 좋음.  
``` c
#include <stdio.h>
#define PI 3.141592f
#define AI_NAME "Jarvis"

int main()
{
	//const float pi = 3.141592f;
	// C++에서는 constexp

	float radius, area, circum;

	printf("I'm %s. Please, input radius\n", AI_NAME);
	scanf("%f", &radius);
	// return value ignored: scanf 에러(또는 경고)는 scanf()의 반환 값을 확인하지 않아서 발생하는 경고.

	area = PI * radius * radius; // area = pi*r*r
	circum = 2.0f * PI * radius; // circum = 2.0 * pi * r

	printf("Area is %f.\n", area);
	printf("Corcumference is %f.\n", circum);

	//TODO: wrong usage, strings, const

	return 0;
}
```


### 📌 4.6 명백한 상수들(Manifest(obvious) Constants)
- #define PI 3.141592 : manifest constants  
  macro : 숫자 뿐만 아니라(ex. <limits.h>), 여러번 사용하는 기능을 정의하면.  
``` c
#include <stdio.h>
#include <limits.h>	// INT_MAX, ..., etc.
#include <float.h>  // FLT_MAX, ..., etc.

#define PI 3.141592	// manifest constants, symbolic constants

int main()
{
	printf("PI is %f\n", PI);
	printf("Biggest int: %d\n", INT_MAX);
	printf("One byte in this system is %d bits\n", CHAR_BIT);
	printf("Smallest normal float %e\n", FLT_MIN);

	return 0;
}
```


### 📌 4.7 printf() 함수의 변환 지정자들(conversion specifiers)
- Format specifier = 전체 형식 지정 문자열  
  Conversion specifier = format specifier 안에서 데이터 변환을 담당하는 부분  
  > 엄밀히 보면 다른 개념이지만, 보통 같은 의미로 통용되는 경우가 많다.
- %g, %G는 알아서 더 짧은 것으로 선택해준다.  
  <img width="500" src="https://github.com/user-attachments/assets/c7eeda18-d77f-45ff-8868-565328f00f63"/>  
  <img width="500" src="https://github.com/user-attachments/assets/0a6999d3-26b8-40c4-a2d5-336c90a133be"/>

- float %f ? double %lf ?  
  <img width="600" src="https://github.com/user-attachments/assets/88e193c3-dbb4-42b9-8ae2-78f9a5fd953e" />  
  1. printf()에서는 %f와 %lf가 동일한 이유  
     C에서 printf()는 가변 인수 함수 (variadic function) 야.  
     가변 인수 함수에서는 `float이 자동으로 double로 변환됨` (이걸 "default argument promotion" 이라고 해).  
     즉, printf("%f", f);에서 f는 내부적으로 double로 변환되어서 넘어감.  
     그래서 printf()에서는 %f와 %lf가 결과적으로 동일하게 동작함.  
  2. scanf()에서는 반드시 %lf를 써야 하는 이유  
     scanf()는 `인자로 전달된 포인터의 타입을 그대로 사용해 데이터를 저장`함.  
     double을 저장할 공간이 8바이트인데, %f를 쓰면 scanf()는 4바이트(float)만 읽고 저장하려고 함.  
     하지만 double이 실제로는 8바이트를 차지하기 때문에 메모리 오류가 발생할 가능성이 있음.  

``` c
#include <stdio.h>
#include <limits.h>
#include <float.h>

int main()
{
	double d = 3.1415926535897932384626433832795028841971693993751058209749445923078164062;

	printf("%c\n", 'A');  // A -> 한글자 표현할 때는 작은 따옴표.
	printf("%s", "I love you\n");  // I love you
	printf("Even if there's a small chance, \
we owe this to everyone who's not in this room to try.\n");  // 편집을 위한 줄바꿈

	printf("\n");
	printf("%d %i %i %i\n", 1004, 1234, INT_MAX, UINT_MAX);// unsigned를 signed(%i)에 넣음. overflow
	printf("%u %u %u\n", 1024, -1, UINT_MAX);			   // 음수(-1)를 unsigned에 넣음. overflow

	printf("\n");
	printf("%f %f %lf\n", 3.141592f, d, d); // l in %lf is ignored
	printf("%a %A\n", d, d);
	printf("%e %E\n", d, d);

	printf("\n");
	printf("%g %g\n", 123456.789, 1234567.89);  // 123457 1.23457e+06
	printf("%G %G\n", 123456.789, 1234567.89);  // 123457 1.23457E+06
	printf("%g %g\n", 0.00012345, 0.000012345);  // 0.00012345 1.2345e-05
	printf("%G %G\n", 0.00012345, 0.000012345);  // 0.00012345 1.2345E-05

	printf("\n");
	printf("%o\n", 9);  // 11 -> 8진수
	// pointer-of operator, d 변수가 사용하고 있는 메모리의 주소를 출력
	printf("%p\n", &d);  // 00000072D32FFC68

	printf("\n");
	printf("%x %X\n", 11, 11);  // b, B
	printf("%%\n", d); // Note the warning. d is ignored.

	printf("\n");
	// 자릿수 맞춰주기
	printf("%9d\n", 12345);   //    12345
	printf("%09d\n", 12345);  //000012345
	printf("%.2f\n", 3.141592);  // 3.14
	printf("%.20f %.20lf\n", d, d);

	printf("\n");
	int n_printed = printf("Counting!");  // printf의 리턴 값은 출력한 글자 개수.
	printf("%u\n", n_printed);

	return 0;
}
```


### 📌 4.8 변환 지정자의 수식어들

























