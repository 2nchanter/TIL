### 📌 13.1 파일 입출력의 작동 원리
<img width="600" src="https://github.com/user-attachments/assets/b7c94491-1627-4feb-a85a-3dd764d34324"/>

<img width="600" src="https://github.com/user-attachments/assets/dff7d25c-8df6-4812-9f73-8c301b9ebefc"/>


### 📌 13.2 텍스트 파일 입출력 예제
<img width="500" src="https://github.com/user-attachments/assets/e2031ebd-9a3c-46f3-95ce-c741f3c7246f"/>

<img width="500" alt="image" src="https://github.com/user-attachments/assets/4eb0dff4-87be-416d-b5ec-134f5d438b88" />

``` c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
	int ch;  // buffer로부터 한글자씩 받아올 수 있도록
	FILE* fr;	//TODO: file pointer to write -> file 자료형에 대한 포인터 선언.
	// ㄴ 파일을 처리할 때 필요한 데이터 묶음에 대한 포인터. (구조체)
	// FILE 이라는 자료형이 있는 것 처럼. 파일 자체에 대한 포인터 인 것 처럼 사용할 예정.

	/*
	typedef struct _iobuf   <- 데이터 묶음.
	{
		char*   _ptr;
		int _cnt;
		char*   _base;
		int _flag;
		int _file;
		int _charbuf;
		int _bufsiz;
		char*   _tmpfname;
	} FILE;
	*/

	//const char* out_filename = "output.txt";	//TODO: Use this

	unsigned long count = 0;

	if (argc != 2)
	{
		printf("Usage: %s filename\n", argv[0]);
		exit(EXIT_FAILURE);
	}

	// fopen은 file 포인터를 반환한다.
	if ((fr = fopen(argv[1], "r")) == NULL)  // NULL 포인터가 반환되었다면, file을 열지 못한 것.
	{
		printf("Can't open %s\n", argv[1]);
		exit(EXIT_FAILURE);
	}

	/*
		fopen mode strings for text files
		- r: reading
		- w: creating-and-writing or over-writing
		- a: appending or creating-and-writing
		- r+: both reading and writing
		- w+: reading and writing, over-writing or creating
		- a+: reading and writing, appending or creating
	*/

	//TODO: open file to write with "w" mode string

	while ((ch = fgetc(fr)) != EOF)	// getc(fr)
	{
		// 어떤 stream을 사용할 것인지만 다르지, ch 내용을 stdout stream으로 출력하는(=화면으로 출력)
		//putc(ch, stdout);	// same as putchar(ch);
		fputc(ch, stdout);  // 더 안정적.(?)

		//TODO: use fputs() to write a file stream!

		count++;
	}

	fclose(fr);
	//TODO:

	printf("FILE %s has %lu characters\n", argv[1], count);

	return 0;
}
```
- practice  
  1. Tip : scanf("%19s", file_path2):  
  19로 입력 크기를 제한하여, 사용자가 20자 이상의 문자열을 입력하지 않도록.  
  나머지 한 자리는 '\0'을 위한 공간 -> 버퍼 오버플로우 방지  
  2. Tip : scanf로 입력을 받으면 '\n'이 버퍼에 남아서, while (getchar() != '\n'); 을 사용하여 남은 \n을 읽고 처리.
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

int main()
{
	int pr;
	FILE* file;
	char file_path[20];
	char text[20];
	int ch;

	printf("PATH : ");
	//fgets(file_path, sizeof(file_path), stdin);
	pr = scanf("%19s", file_path);
	if (pr != 1) exit(1);
	while (getchar() != '\n');

	printf("TXT : ");
	fgets(text, sizeof(text), stdin);

	// write
	file = fopen(file_path, "w");
	if (!file) exit(1);

	for (int i = 0; text[i] != '\0'; ++i)
		fputc(text[i], file);

	fclose(file);

	// read
	file = fopen(file_path, "r");
	if (!file) exit(1);

	while ((ch = fgetc(file)) != EOF)
		putchar(ch);

	fclose(file);

	return 0;
}
```


### 📌 13.3 텍스트 인코딩(incoding)과 코드 페이지(code page)
- Windows (CRLF)  
  `CR`: Carriage Return (캐리지 리턴) - `\r`  
  `LF`: Line Feed (라인 피드) - `\n`  
  Windows에서는 줄 바꿈을 할 때 \r\n을 사용합니다.  
  Unix/Linux와 macOS에서는 \n만 사용합니다 (LF만).
- UTF-8, ANSI ... (인코딩 방식)
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>	// SetConsoleOutputCP()

int main()
{
	const UINT default_cp = GetConsoleOutputCP();
	printf("%u\n", default_cp);

	int ch;
	FILE* fr, * fw;

	const char* in_filename = "����.txt";
	const char* out_filename = "�纻.txt";

	unsigned long count = 0;

	if ((fr = fopen(in_filename, "r")) == NULL)	// Open a text file for reading.
	{
		printf("Can't open %s\n", in_filename);
		exit(EXIT_FAILURE);
	}

	if ((fw = fopen(out_filename, "w")) == NULL)	// Open a text file for writing.
	{
		printf("Can't open %s\n", out_filename);
		exit(EXIT_FAILURE);
	}

	SetConsoleOutputCP(CP_UTF8);// UTF-8 mode

	while ((ch = fgetc(fr)) != EOF)
	{
		fputc(ch, stdout);	// same as putchar(ch);
		fputc(ch, fw);
		count++;
	}

	fclose(fr);
	fclose(fw);

	SetConsoleOutputCP(default_cp);// ISO 2022 Korean

	printf("FILE %s has %lu characters\n", in_filename, count);
	printf("Copied to %s\n", out_filename);

	printf("�ѱ� ��� Ȯ��");

	return 0;
}
```


### 📌 13.4 텍스트 파일 입출력 함수들 (fprintf(), fscanf(), fgets(), fputs())
<img width="500" alt="image" src="https://github.com/user-attachments/assets/2d70d8be-eee5-416d-a541-0ad010915451" />

<img width="700" alt="image" src="https://github.com/user-attachments/assets/18a196f1-5f14-4dd2-bfea-c9aa60c7236e" />

``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX 31

int main(void)
{
	FILE* fp;
	char words[MAX] = { '\0', };

	const char* filename = "record.txt";

	/*
	fopen() mode strings for text files
	- r: reading
	- w: creating-and-writing or over-writing
	- a: appending or creating-and-writing
	- r+: both reading and writing
	- w+: reading and writing, over-writing or creating
	- a+: reading and writing, appending or creating
	*/

	if ((fp = fopen(filename, "w+")) == NULL)// Try r+, w+, a+
	{
		fprintf(stderr, "Can't open \"%s\" file.\n", filename);
		exit(EXIT_FAILURE);
	}

	//while ((fscanf(stdin, "%30s", words) == 1) && (words[0] != '.'))
	//	fprintf(fp, "%s\n", words);

	while ((fgets(words, MAX, stdin) != NULL) && (words[0] != '.'))
		fputs(words, fp);

	rewind(fp);  /* go back to beginning of file */

	//while (fscanf(fp, "%s", words) != EOF)
	//	fprintf(stdout, "%s\n", words);

	while (fgets(words, MAX, fp) != NULL)// EOF check
		fputs(words, stdout);

	if (fclose(fp) != 0)
		fprintf(stderr, "Error closing file\n");

	return 0;
}
```


### 📌 13.5 바이너리 파일 입출력
<img width="700" alt="image" src="https://github.com/user-attachments/assets/356057ab-57d9-4862-8b67-06a13b2b95f3" />

``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

int main()
{
	/*
	fopen() mode string for binary IO
	- "rb", "wb", "ab"
	- "ab+", "a+b"
	- "wb+", "w+b"
	- "ab+", "a+b"

	C11 'x' mode fails if the file exists, instead of overwriting it.
	- "wx", "wbx", "w+x", "wb+x", "w+bx"
	*/

	// Writing example
	{
		FILE* fp = fopen("binary_file", "wb");

		double d = 1.0 / 3.0;
		int n = 123;
		int* parr = (int*)malloc(sizeof(int) * n);
		if (!parr) exit(1);
		for (int n = 0; n < 123; ++n)
			*(parr + n) = n * 2;

		// size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream);
		// (데이터를 저장한 메모리 버퍼에 대한 포인터, 한 개의 항목이 차지하는 크기(바이트),
		//  size 크기의 항목이 몇 개가 쓰일지 지정, 데이터를 쓸 파일 포인터)
		fwrite(&d, sizeof(d), 1, fp);
		fwrite(&n, sizeof(n), 1, fp);
		fwrite(parr, sizeof(int), n, fp);

		fclose(fp);
		free(parr);

		// Total size is 8 * 1 + 4 * 1 + 123 * 4 = 504 bytes
	}
	// Reading example, feof(), ferror()
	{
		FILE* fp = fopen("binary_file", "rb");
		double d;
		int n = 0;
		fread(&d, sizeof(d), 1, fp);
		fread(&n, sizeof(n), 1, fp);

		int* parr = (int*)malloc(sizeof(int) * n); 
		if (!parr) exit(1);

		fread(parr, sizeof(int), n, fp);

		// 저장된 갯수만큼만 불러왔기 때문에 EOF를 만나지 않았음 = 0
		printf("feof = %d\n", feof(fp));

		printf("%f\n", d);
		printf("%d\n", n);
		for (int i = 0; i < n; ++i)
			printf("%d ", *(parr + i));
		printf("\n");

		printf("feof = %d\n", feof(fp));

		fread(&n, sizeof(n), 1, fp);		 // read one more toward EOF

		// EOF 만났음 = 1
		printf("feof = %d\n", feof(fp));     // returns non-zero at EOF
		printf("ferror = %d\n", ferror(fp)); // returns 0 : ok

		fwrite(&n, sizeof(n), 1, fp);		 // try writing to make an error

		printf("ferror = %d\n", ferror(fp)); // 0 is ok, non-zero otherwise.

		fclose(fp);
		free(parr);
	}

	return 0;
}
```


### 📌 13.6 파일 임의 접근(Random Access)

<img width="450" alt="image" src="https://github.com/user-attachments/assets/e146e981-b436-4850-8b0b-4daa5fc7ed1c" />
















