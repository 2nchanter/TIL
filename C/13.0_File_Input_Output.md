### ğŸ“Œ 13.1 íŒŒì¼ ì…ì¶œë ¥ì˜ ì‘ë™ ì›ë¦¬
<img width="600" src="https://github.com/user-attachments/assets/b7c94491-1627-4feb-a85a-3dd764d34324"/>

<img width="600" src="https://github.com/user-attachments/assets/dff7d25c-8df6-4812-9f73-8c301b9ebefc"/>


### ğŸ“Œ 13.2 í…ìŠ¤íŠ¸ íŒŒì¼ ì…ì¶œë ¥ ì˜ˆì œ
<img width="500" src="https://github.com/user-attachments/assets/e2031ebd-9a3c-46f3-95ce-c741f3c7246f"/>

<img width="500" alt="image" src="https://github.com/user-attachments/assets/4eb0dff4-87be-416d-b5ec-134f5d438b88" />

``` c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
	int ch;  // bufferë¡œë¶€í„° í•œê¸€ìì”© ë°›ì•„ì˜¬ ìˆ˜ ìˆë„ë¡
	FILE* fr;	//TODO: file pointer to write -> file ìë£Œí˜•ì— ëŒ€í•œ í¬ì¸í„° ì„ ì–¸.
	// ã„´ íŒŒì¼ì„ ì²˜ë¦¬í•  ë•Œ í•„ìš”í•œ ë°ì´í„° ë¬¶ìŒì— ëŒ€í•œ í¬ì¸í„°. (êµ¬ì¡°ì²´)
	// FILE ì´ë¼ëŠ” ìë£Œí˜•ì´ ìˆëŠ” ê²ƒ ì²˜ëŸ¼. íŒŒì¼ ìì²´ì— ëŒ€í•œ í¬ì¸í„° ì¸ ê²ƒ ì²˜ëŸ¼ ì‚¬ìš©í•  ì˜ˆì •.

	/*
	typedef struct _iobuf   <- ë°ì´í„° ë¬¶ìŒ.
	{
		char*   _ptr;
		int _cnt;
		char*   _base;
		int _flag;
		int _file;
		int _charbuf;
		int _bufsiz;
		char*   _tmpfname;
	} FILE;
	*/

	//const char* out_filename = "output.txt";	//TODO: Use this

	unsigned long count = 0;

	if (argc != 2)
	{
		printf("Usage: %s filename\n", argv[0]);
		exit(EXIT_FAILURE);
	}

	// fopenì€ file í¬ì¸í„°ë¥¼ ë°˜í™˜í•œë‹¤.
	if ((fr = fopen(argv[1], "r")) == NULL)  // NULL í¬ì¸í„°ê°€ ë°˜í™˜ë˜ì—ˆë‹¤ë©´, fileì„ ì—´ì§€ ëª»í•œ ê²ƒ.
	{
		printf("Can't open %s\n", argv[1]);
		exit(EXIT_FAILURE);
	}

	/*
		fopen mode strings for text files
		- r: reading
		- w: creating-and-writing or over-writing
		- a: appending or creating-and-writing
		- r+: both reading and writing
		- w+: reading and writing, over-writing or creating
		- a+: reading and writing, appending or creating
	*/

	//TODO: open file to write with "w" mode string

	while ((ch = fgetc(fr)) != EOF)	// getc(fr)
	{
		// ì–´ë–¤ streamì„ ì‚¬ìš©í•  ê²ƒì¸ì§€ë§Œ ë‹¤ë¥´ì§€, ch ë‚´ìš©ì„ stdout streamìœ¼ë¡œ ì¶œë ¥í•˜ëŠ”(=í™”ë©´ìœ¼ë¡œ ì¶œë ¥)
		//putc(ch, stdout);	// same as putchar(ch);
		fputc(ch, stdout);  // ë” ì•ˆì •ì .(?)

		//TODO: use fputs() to write a file stream!

		count++;
	}

	fclose(fr);
	//TODO:

	printf("FILE %s has %lu characters\n", argv[1], count);

	return 0;
}
```
- practice  
  1. Tip : scanf("%19s", file_path2):  
  19ë¡œ ì…ë ¥ í¬ê¸°ë¥¼ ì œí•œí•˜ì—¬, ì‚¬ìš©ìê°€ 20ì ì´ìƒì˜ ë¬¸ìì—´ì„ ì…ë ¥í•˜ì§€ ì•Šë„ë¡.  
  ë‚˜ë¨¸ì§€ í•œ ìë¦¬ëŠ” '\0'ì„ ìœ„í•œ ê³µê°„ -> ë²„í¼ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€  
  2. Tip : scanfë¡œ ì…ë ¥ì„ ë°›ìœ¼ë©´ '\n'ì´ ë²„í¼ì— ë‚¨ì•„ì„œ, while (getchar() != '\n'); ì„ ì‚¬ìš©í•˜ì—¬ ë‚¨ì€ \nì„ ì½ê³  ì²˜ë¦¬.
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

int main()
{
	int pr;
	FILE* file;
	char file_path[20];
	char text[20];
	int ch;

	printf("PATH : ");
	//fgets(file_path, sizeof(file_path), stdin);
	pr = scanf("%19s", file_path);
	if (pr != 1) exit(1);
	while (getchar() != '\n');

	printf("TXT : ");
	fgets(text, sizeof(text), stdin);

	// write
	file = fopen(file_path, "w");
	if (!file) exit(1);

	for (int i = 0; text[i] != '\0'; ++i)
		fputc(text[i], file);

	fclose(file);

	// read
	file = fopen(file_path, "r");
	if (!file) exit(1);

	while ((ch = fgetc(file)) != EOF)
		putchar(ch);

	fclose(file);

	return 0;
}
```


### ğŸ“Œ 13.3 í…ìŠ¤íŠ¸ ì¸ì½”ë”©(incoding)ê³¼ ì½”ë“œ í˜ì´ì§€(code page)
- Windows (CRLF)  
  `CR`: Carriage Return (ìºë¦¬ì§€ ë¦¬í„´) - `\r`  
  `LF`: Line Feed (ë¼ì¸ í”¼ë“œ) - `\n`  
  Windowsì—ì„œëŠ” ì¤„ ë°”ê¿ˆì„ í•  ë•Œ \r\nì„ ì‚¬ìš©í•©ë‹ˆë‹¤.  
  Unix/Linuxì™€ macOSì—ì„œëŠ” \në§Œ ì‚¬ìš©í•©ë‹ˆë‹¤ (LFë§Œ).
- UTF-8, ANSI ... (ì¸ì½”ë”© ë°©ì‹)
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>	// SetConsoleOutputCP()

int main()
{
	const UINT default_cp = GetConsoleOutputCP();
	printf("%u\n", default_cp);

	int ch;
	FILE* fr, * fw;

	const char* in_filename = "ï¿½ï¿½ï¿½ï¿½.txt";
	const char* out_filename = "ï¿½çº».txt";

	unsigned long count = 0;

	if ((fr = fopen(in_filename, "r")) == NULL)	// Open a text file for reading.
	{
		printf("Can't open %s\n", in_filename);
		exit(EXIT_FAILURE);
	}

	if ((fw = fopen(out_filename, "w")) == NULL)	// Open a text file for writing.
	{
		printf("Can't open %s\n", out_filename);
		exit(EXIT_FAILURE);
	}

	SetConsoleOutputCP(CP_UTF8);// UTF-8 mode

	while ((ch = fgetc(fr)) != EOF)
	{
		fputc(ch, stdout);	// same as putchar(ch);
		fputc(ch, fw);
		count++;
	}

	fclose(fr);
	fclose(fw);

	SetConsoleOutputCP(default_cp);// ISO 2022 Korean

	printf("FILE %s has %lu characters\n", in_filename, count);
	printf("Copied to %s\n", out_filename);

	printf("ï¿½Ñ±ï¿½ ï¿½ï¿½ï¿½ È®ï¿½ï¿½");

	return 0;
}
```


### ğŸ“Œ 13.4 í…ìŠ¤íŠ¸ íŒŒì¼ ì…ì¶œë ¥ í•¨ìˆ˜ë“¤ (fprintf(), fscanf(), fgets(), fputs())
<img width="500" alt="image" src="https://github.com/user-attachments/assets/2d70d8be-eee5-416d-a541-0ad010915451" />

<img width="700" alt="image" src="https://github.com/user-attachments/assets/18a196f1-5f14-4dd2-bfea-c9aa60c7236e" />

``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX 31

int main(void)
{
	FILE* fp;
	char words[MAX] = { '\0', };

	const char* filename = "record.txt";

	/*
	fopen() mode strings for text files
	- r: reading
	- w: creating-and-writing or over-writing
	- a: appending or creating-and-writing
	- r+: both reading and writing
	- w+: reading and writing, over-writing or creating
	- a+: reading and writing, appending or creating
	*/

	if ((fp = fopen(filename, "w+")) == NULL)// Try r+, w+, a+
	{
		fprintf(stderr, "Can't open \"%s\" file.\n", filename);
		exit(EXIT_FAILURE);
	}

	//while ((fscanf(stdin, "%30s", words) == 1) && (words[0] != '.'))
	//	fprintf(fp, "%s\n", words);

	while ((fgets(words, MAX, stdin) != NULL) && (words[0] != '.'))
		fputs(words, fp);

	rewind(fp);  /* go back to beginning of file */

	//while (fscanf(fp, "%s", words) != EOF)
	//	fprintf(stdout, "%s\n", words);

	while (fgets(words, MAX, fp) != NULL)// EOF check
		fputs(words, stdout);

	if (fclose(fp) != 0)
		fprintf(stderr, "Error closing file\n");

	return 0;
}
```


### ğŸ“Œ 13.5 ë°”ì´ë„ˆë¦¬ íŒŒì¼ ì…ì¶œë ¥
<img width="700" alt="image" src="https://github.com/user-attachments/assets/356057ab-57d9-4862-8b67-06a13b2b95f3" />

- `fread()` - ë°”ì´ë„ˆë¦¬ íŒŒì¼ì—ì„œ ë°ì´í„° ì½ì„ ë•Œ ì‚¬ìš©.  
  í…ìŠ¤íŠ¸ íŒŒì¼ë„ ì½ì„ ìˆ˜ ìˆì§€ë§Œ, fscanf()ë‚˜ fgets()ë¥¼ ë” ìì£¼ ì‚¬ìš©  
  `fwrite()` - ë°”ì´ë„ˆë¦¬ íŒŒì¼ì— ë°ì´í„°ë¥¼ ì“¸ ë•Œ ì‚¬ìš©.  
  í…ìŠ¤íŠ¸ íŒŒì¼ë„ ì“¸ ìˆ˜ ìˆì§€ë§Œ, fprintf()ë‚˜ fputs()ë¥¼ ë” ìì£¼ ì‚¬ìš©
  `feof()` - íŒŒì¼ ë(EOF) í™•ì¸  
  while (!feof(fp)) ê°™ì€ í˜•íƒœë¡œ ì‚¬ìš©ë¨, ì½ê¸° ë£¨í”„ì—ì„œ EOFë¥¼ í™•ì¸í•˜ëŠ” ìš©ë„ë¡œ ì‚¬ìš©  
  `ferror()` - íŒŒì¼ ì—ëŸ¬ í™•ì¸  
  íŒŒì¼ ì½ê¸°/ì“°ê¸° ê³¼ì •ì—ì„œ ì—ëŸ¬ ë°œìƒ ì—¬ë¶€ í™•ì¸, if (ferror(fp)) { perror("íŒŒì¼ ì˜¤ë¥˜"); } ì²˜ëŸ¼ ì‚¬ìš©

``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

int main()
{
	/*
	fopen() mode string for binary IO
	- "rb", "wb", "ab"
	- "ab+", "a+b"
	- "wb+", "w+b"
	- "ab+", "a+b"

	C11 'x' mode fails if the file exists, instead of overwriting it.
	- "wx", "wbx", "w+x", "wb+x", "w+bx"
	*/

	// Writing example
	{
		FILE* fp = fopen("binary_file", "wb");

		double d = 1.0 / 3.0;
		int n = 123;
		int* parr = (int*)malloc(sizeof(int) * n);
		if (!parr) exit(1);
		for (int n = 0; n < 123; ++n)
			*(parr + n) = n * 2;

		// size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream);
		// (ë°ì´í„°ë¥¼ ì €ì¥í•œ ë©”ëª¨ë¦¬ ë²„í¼ì— ëŒ€í•œ í¬ì¸í„°, í•œ ê°œì˜ í•­ëª©ì´ ì°¨ì§€í•˜ëŠ” í¬ê¸°(ë°”ì´íŠ¸),
		//  size í¬ê¸°ì˜ í•­ëª©ì´ ëª‡ ê°œê°€ ì“°ì¼ì§€ ì§€ì •, ë°ì´í„°ë¥¼ ì“¸ íŒŒì¼ í¬ì¸í„°)
		fwrite(&d, sizeof(d), 1, fp);
		fwrite(&n, sizeof(n), 1, fp);
		fwrite(parr, sizeof(int), n, fp);

		fclose(fp);
		free(parr);

		// Total size is 8 * 1 + 4 * 1 + 123 * 4 = 504 bytes
	}
	// Reading example, feof(), ferror()
	{
		FILE* fp = fopen("binary_file", "rb");
		double d;
		int n = 0;
		fread(&d, sizeof(d), 1, fp);
		fread(&n, sizeof(n), 1, fp);

		int* parr = (int*)malloc(sizeof(int) * n); 
		if (!parr) exit(1);

		fread(parr, sizeof(int), n, fp);

		// ì €ì¥ëœ ê°¯ìˆ˜ë§Œí¼ë§Œ ë¶ˆëŸ¬ì™”ê¸° ë•Œë¬¸ì— EOFë¥¼ ë§Œë‚˜ì§€ ì•Šì•˜ìŒ = 0
		printf("feof = %d\n", feof(fp));

		printf("%f\n", d);
		printf("%d\n", n);
		for (int i = 0; i < n; ++i)
			printf("%d ", *(parr + i));
		printf("\n");

		printf("feof = %d\n", feof(fp));

		fread(&n, sizeof(n), 1, fp);		 // read one more toward EOF

		// EOF ë§Œë‚¬ìŒ = 1
		printf("feof = %d\n", feof(fp));     // returns non-zero at EOF
		printf("ferror = %d\n", ferror(fp)); // returns 0 : ok

		fwrite(&n, sizeof(n), 1, fp);		 // try writing to make an error

		printf("ferror = %d\n", ferror(fp)); // 0 is ok, non-zero otherwise.

		fclose(fp);
		free(parr);
	}

	return 0;
}
```


### ğŸ“Œ 13.6 íŒŒì¼ ì„ì˜ ì ‘ê·¼(Random Access)
<img width="450" alt="image" src="https://github.com/user-attachments/assets/e146e981-b436-4850-8b0b-4daa5fc7ed1c" />
<img width="450" alt="image" src="https://github.com/user-attachments/assets/918eab43-456b-4283-bccc-040d02bc192c" />

``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main()
{
	// make a test binary file
	{
		FILE* fp = fopen("binary", "wb");
		for (int i = 0; i < 100; ++i)
		{
			double d = i * 1.11;
			fwrite(&d, sizeof(double), 1, fp);
		}
		fclose(fp);
	}

	// read

	FILE* fp = fopen("binary", "rb");
	long cur;
	double d;

	cur = ftell(fp);
	printf("Before reading %ld\n", cur);

	fread(&d, sizeof(double), 1, fp);

	cur = ftell(fp);
	printf("After reading %ld\n", cur);

	printf("%f\n", d);

	fread(&d, sizeof(double), 1, fp);
	printf("%f\n", d);

	cur = ftell(fp);
	printf("After reading %ld\n", cur);

	fseek(fp, 32L, SEEK_SET);	// 32 = 4 * 8
	fread(&d, sizeof(double), 1, fp);
	printf("%f\n", d);

	fclose(fp);

	return 0;
}
```


### ğŸ“Œ ì •ë¦¬
- ì…ë ¥ í•¨ìˆ˜:  
  âœ… `scanf`: í‘œì¤€ ì…ë ¥ì—ì„œ í˜•ì‹í™”ëœ ë°ì´í„°ë¥¼ ì½ì„ ë•Œ ì‚¬ìš©. ê³µë°±(ìŠ¤í˜ì´ìŠ¤, íƒ­, ê°œí–‰ ë“±)ìœ¼ë¡œ êµ¬ë¶„í•˜ì—¬ ì½ê¸° ë•Œë¬¸ì— \nì€ ì½ì§€ ì•ŠìŒ.  
  âœ… `fscanf`: íŒŒì¼ì—ì„œ í˜•ì‹í™”ëœ ë°ì´í„°ë¥¼ ì½ì„ ë•Œ ì‚¬ìš©. ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•˜ì—¬ ë°ì´í„°ë¥¼ ì½ìœ¼ë©°, \nì€ ì½ì§€ ì•ŠìŒ.  
  ã„´ ë°˜í™˜ ê°’: ì„±ê³µ: ì½ì€ í•­ëª© ê°œìˆ˜, ì‹¤íŒ¨: EOF  
  âœ… `getc`: í‘œì¤€ ì…ë ¥ì—ì„œ í•œ ë¬¸ìë¥¼ ì½ì„ ë•Œ ì‚¬ìš©. \në„ ë¬¸ìë¡œ ì½ìŒ.  
  âœ… `fgetc`: íŒŒì¼ì—ì„œ í•œ ë¬¸ìë¥¼ ì½ì„ ë•Œ ì‚¬ìš©. \në„ ë¬¸ìë¡œ ì½ìŒ.  
  ã„´ ë°˜í™˜ ê°’: ì½ì€ ë¬¸ì(int), ì‹¤íŒ¨ ì‹œ EOF  
  gets: ë²„í¼ ì˜¤ë²„í”Œë¡œìš°ì˜ ìœ„í—˜ì´ ìˆì–´ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ. í‘œì¤€ ì…ë ¥ì—ì„œ ë¬¸ìì—´ì„ ì½ì§€ë§Œ, \nì€ ìë™ìœ¼ë¡œ ë²„ë¦¬ê³  ì½ìŒ.  
  `fgets`: í‘œì¤€ ì…ë ¥ ë˜ëŠ” íŒŒì¼ì—ì„œ ë¬¸ìì—´ì„ ì½ì„ ë•Œ ì‚¬ìš©. \nì„ í¬í•¨í•˜ì—¬ ë¬¸ìì—´ì„ ì½ìŒ.  
  ã„´ ë°˜í™˜ ê°’: ì½ì€ ë¬¸ìì—´, ì‹¤íŒ¨ ì‹œ `NULL`  
- ì¶œë ¥ í•¨ìˆ˜:  
  âœ… `printf`: í‘œì¤€ ì¶œë ¥ì— í˜•ì‹í™”ëœ ë°ì´í„°ë¥¼ ì¶œë ¥í•  ë•Œ ì‚¬ìš©. ê°œí–‰ ë¬¸ìë¥¼ ìë™ìœ¼ë¡œ ì¶”ê°€í•˜ì§€ ì•ŠìŒ.  
  âœ… `fprintf`: íŒŒì¼ì— í˜•ì‹í™”ëœ ë°ì´í„°ë¥¼ ì¶œë ¥í•  ë•Œ ì‚¬ìš©. ê°œí–‰ ë¬¸ìë¥¼ ìë™ìœ¼ë¡œ ì¶”ê°€í•˜ì§€ ì•ŠìŒ.  
  ã„´ ë°˜í™˜ ê°’: ì¶œë ¥ëœ ë¬¸ì ê°œìˆ˜  
  âœ… `putc`: í‘œì¤€ ì¶œë ¥ì— í•œ ë¬¸ìë¥¼ ì¶œë ¥í•  ë•Œ ì‚¬ìš©.  
  âœ… `fputc`: íŒŒì¼ì— í•œ ë¬¸ìë¥¼ ì¶œë ¥í•  ë•Œ ì‚¬ìš©.  
  ã„´ ë°˜í™˜ ê°’: ì¶œë ¥í•œ ë¬¸ì, ì‹¤íŒ¨ ì‹œ EOF  
  `puts`: í‘œì¤€ ì¶œë ¥ì— ë¬¸ìì—´ì„ ì¶œë ¥í•  ë•Œ ì‚¬ìš©. `ìë™ìœ¼ë¡œ \nì„ ì¶”ê°€`í•˜ì—¬ ì¶œë ¥ í›„ ì¤„ë°”ê¿ˆ.  
  ã„´ ë°˜í™˜ ê°’: ì„±ê³µ ì‹œ ì–‘ì˜ ì •ìˆ˜ (ì¼ë°˜ì ìœ¼ë¡œ ì¶œë ¥ëœ ë¬¸ì ê°œìˆ˜), ì‹¤íŒ¨ ì‹œ EOF  
  `fputs`: íŒŒì¼ì— ë¬¸ìì—´ì„ ì¶œë ¥í•  ë•Œ ì‚¬ìš©. ìë™ìœ¼ë¡œ \nì„ ì¶”ê°€í•˜ì§€ ì•ŠìŒ.  
  ã„´ ë°˜í™˜ ê°’: ì„±ê³µ: 0, ì‹¤íŒ¨ ì‹œ EOF  
``` c
#include <stdio.h>

int main()
{
	/* scanf, printf */
	char c;

	scanf("%c", &c);
	printf("%c", c);
	
	

	/* fscanf, fprintf */
	int num;
	char s[50];
	FILE* fp;
		
	fp = fopen("test.txt", "r");
	while (fscanf(fp, "%d %s", &num, s) != EOF)
		printf("%d %s\n", num, s);
	fclose(fp);

	fp = fopen("test.txt", "a");
	fprintf(fp, "%d %s\n", 100, "Apple");
	fclose(fp);

	fp = fopen("test.txt", "r");
	while (fscanf(fp, "%d %s", &num, s) != EOF)
		printf("%d %s\n", num, s);
	fclose(fp);



	/* getc, fgetc, putc, fputc */
	char c;
	FILE* fp;

	// write
	c = getc(stdin);
	//putc(c, stdout);
	fp = fopen("test.txt", "a");
	fputc(c, fp);
	fclose(fp);

	// read
	fp = fopen("test.txt", "r");
	while ((c = fgetc(fp)) != EOF)
		putc(c, stdout);
	fclose(fp);



	/* gets, fgets, puts, fputs */
	char s[50];
	FILE* fp;

	// no file
	fgets(s, sizeof(s), stdin);
	//puts(s);
	fputs(s, stdout);

	// in file
	fp = fopen("test.txt", "w");
	fputs(s, fp);
	fclose(fp);

	return 0;
}
```


### ğŸ“Œ 13.7 ê¸°íƒ€ ì…ì¶œë ¥ í•¨ìˆ˜ë“¤ (ungetc(), fflush(), setvbuf())
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main()
{
	FILE* fp;
	int ch;

	/* ungetc() : bufferì— intí˜• ê°’ì„ ë„£ëŠ” í•¨ìˆ˜. */ 
	fp = fopen("input.txt", "r");

	ch = fgetc(fp);
	fputc(ch, stdout);

	ungetc((int)'A', fp);

	ch = fgetc(fp);
	fputc(ch, stdout);

	ch = fgetc(fp);
	fputc(ch, stdout);

	fclose(fp);



	/* setvbuf() : bufferì˜ ì„±ì§ˆì„ ë³€ê²½í•´ì£¼ëŠ” í•¨ìˆ˜. */
	// bufferëŠ” í”„ë¡œê·¸ë¨ì´ í•´ë‹¹ íŒŒì¼ì„ ê³„ì† ì½ì„ ê²ƒ ê°™ìœ¼ë©´, ë¯¸ë¦¬ bufferì— ë„£ì–´ë†“ëŠ”ë‹¤.

	fp = fopen("input.txt", "r");

	char buffer[32] = {'\0',};

	setvbuf(fp, buffer, _IOFBF, sizeof(buffer));	// _IOLBF, _IOFBF, _IONBF
	
	// dump buffer
	for (int i = 0; i < sizeof(buffer); ++i)
		printf("%hhd", buffer[i]);  // 00000000000000000000000000000000
	printf("\n");

	ch = fgetc(fp);	 // í•œê¸€ìë§Œ ì½ì—ˆìŒ.

	// dump buffer
	for (int i = 0; i < sizeof(buffer); ++i)
			printf("%c", buffer[i]);  // abcdefghijklmnop  <- í•œê¸€ìë§Œ ê°–ê³  ì™”ëŠ”ë° ì „ë¶€ ì¶œë ¥ë¨. (
		printf("\n");

	fclose(fp);



    /* fflush() */
	// fflush()ëŠ” ì¶œë ¥ ìŠ¤íŠ¸ë¦¼(stdout, íŒŒì¼)ì—ì„œ ë²„í¼ë¥¼ ë¹„ìš¸ ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.
	// íŒŒì¼ ì“°ê¸° í›„ ì¦‰ì‹œ ì €ì¥, printf() ì¶œë ¥ ì¦‰ì‹œ ë°˜ì˜ ê°™ì€ ê²½ìš°ì— ìì£¼ ì‚¬ìš©

	fflush(fp);

	return 0;
}
```


### ğŸ“Œ 13.8 í…ìŠ¤íŠ¸ íŒŒì¼ì„ ë°”ì´ë„ˆë¦¬ ì²˜ëŸ¼ ì½ì–´ë³´ê¸°



















