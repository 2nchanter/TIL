### 📌 13.1 파일 입출력의 작동 원리
<img width="600" src="https://github.com/user-attachments/assets/b7c94491-1627-4feb-a85a-3dd764d34324"/>

<img width="600" src="https://github.com/user-attachments/assets/dff7d25c-8df6-4812-9f73-8c301b9ebefc"/>


### 📌 13.2 텍스트 파일 입출력 예제
<img width="500" src="https://github.com/user-attachments/assets/e2031ebd-9a3c-46f3-95ce-c741f3c7246f"/>

<img width="500" alt="image" src="https://github.com/user-attachments/assets/4eb0dff4-87be-416d-b5ec-134f5d438b88" />

``` c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
	int ch;  // buffer로부터 한글자씩 받아올 수 있도록
	FILE* fr;	//TODO: file pointer to write -> file 자료형에 대한 포인터 선언.
	// ㄴ 파일을 처리할 때 필요한 데이터 묶음에 대한 포인터. (구조체)
	// FILE 이라는 자료형이 있는 것 처럼. 파일 자체에 대한 포인터 인 것 처럼 사용할 예정.

	/*
	typedef struct _iobuf   <- 데이터 묶음.
	{
		char*   _ptr;
		int _cnt;
		char*   _base;
		int _flag;
		int _file;
		int _charbuf;
		int _bufsiz;
		char*   _tmpfname;
	} FILE;
	*/

	//const char* out_filename = "output.txt";	//TODO: Use this

	unsigned long count = 0;

	if (argc != 2)
	{
		printf("Usage: %s filename\n", argv[0]);
		exit(EXIT_FAILURE);
	}

	// fopen은 file 포인터를 반환한다.
	if ((fr = fopen(argv[1], "r")) == NULL)  // NULL 포인터가 반환되었다면, file을 열지 못한 것.
	{
		printf("Can't open %s\n", argv[1]);
		exit(EXIT_FAILURE);
	}

	/*
		fopen mode strings for text files
		- r: reading
		- w: creating-and-writing or over-writing
		- a: appending or creating-and-writing
		- r+: both reading and writing
		- w+: reading and writing, over-writing or creating
		- a+: reading and writing, appending or creating
	*/

	//TODO: open file to write with "w" mode string

	while ((ch = fgetc(fr)) != EOF)	// getc(fr)
	{
		// 어떤 stream을 사용할 것인지만 다르지, ch 내용을 stdout stream으로 출력하는(=화면으로 출력)
		//putc(ch, stdout);	// same as putchar(ch);
		fputc(ch, stdout);  // 더 안정적.(?)

		//TODO: use fputs() to write a file stream!

		count++;
	}

	fclose(fr);
	//TODO:

	printf("FILE %s has %lu characters\n", argv[1], count);

	return 0;
}
```
- practice
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

int main()
{
	int ch, sf;
	FILE* file;
	char file_path[] = "test.txt";
	char file_path2[20] = "";

	printf("Typing path : ");
	sf = scanf("%19s", file_path2);
	if (sf != 1) exit(1);

	file = fopen(file_path2, "a+");
	if (!file) exit(1);

	while ((ch = fgetc(file)) != EOF)
		putchar(ch);
	fclose(file);

	return 0;
}
```
- Tip : scanf("%19s", file_path2):  
  19로 입력 크기를 제한하여, 사용자가 100자 이상의 문자열을 입력하지 않도록.  
  나머지 한 자리는 **널 종료 문자 \0**를 위한 공간 -> 버퍼 오버플로우 방지

















