### ğŸ“Œ 13.1 íŒŒì¼ ì…ì¶œë ¥ì˜ ì‘ë™ ì›ë¦¬
<img width="600" src="https://github.com/user-attachments/assets/b7c94491-1627-4feb-a85a-3dd764d34324"/>

<img width="600" src="https://github.com/user-attachments/assets/dff7d25c-8df6-4812-9f73-8c301b9ebefc"/>


### ğŸ“Œ 13.2 í…ìŠ¤íŠ¸ íŒŒì¼ ì…ì¶œë ¥ ì˜ˆì œ
<img width="500" src="https://github.com/user-attachments/assets/e2031ebd-9a3c-46f3-95ce-c741f3c7246f"/>

<img width="500" alt="image" src="https://github.com/user-attachments/assets/4eb0dff4-87be-416d-b5ec-134f5d438b88" />

``` c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
	int ch;  // bufferë¡œë¶€í„° í•œê¸€ìì”© ë°›ì•„ì˜¬ ìˆ˜ ìˆë„ë¡
	FILE* fr;	//TODO: file pointer to write -> file ìë£Œí˜•ì— ëŒ€í•œ í¬ì¸í„° ì„ ì–¸.
	// ã„´ íŒŒì¼ì„ ì²˜ë¦¬í•  ë•Œ í•„ìš”í•œ ë°ì´í„° ë¬¶ìŒì— ëŒ€í•œ í¬ì¸í„°. (êµ¬ì¡°ì²´)
	// FILE ì´ë¼ëŠ” ìë£Œí˜•ì´ ìˆëŠ” ê²ƒ ì²˜ëŸ¼. íŒŒì¼ ìì²´ì— ëŒ€í•œ í¬ì¸í„° ì¸ ê²ƒ ì²˜ëŸ¼ ì‚¬ìš©í•  ì˜ˆì •.

	/*
	typedef struct _iobuf   <- ë°ì´í„° ë¬¶ìŒ.
	{
		char*   _ptr;
		int _cnt;
		char*   _base;
		int _flag;
		int _file;
		int _charbuf;
		int _bufsiz;
		char*   _tmpfname;
	} FILE;
	*/

	//const char* out_filename = "output.txt";	//TODO: Use this

	unsigned long count = 0;

	if (argc != 2)
	{
		printf("Usage: %s filename\n", argv[0]);
		exit(EXIT_FAILURE);
	}

	// fopenì€ file í¬ì¸í„°ë¥¼ ë°˜í™˜í•œë‹¤.
	if ((fr = fopen(argv[1], "r")) == NULL)  // NULL í¬ì¸í„°ê°€ ë°˜í™˜ë˜ì—ˆë‹¤ë©´, fileì„ ì—´ì§€ ëª»í•œ ê²ƒ.
	{
		printf("Can't open %s\n", argv[1]);
		exit(EXIT_FAILURE);
	}

	/*
		fopen mode strings for text files
		- r: reading
		- w: creating-and-writing or over-writing
		- a: appending or creating-and-writing
		- r+: both reading and writing
		- w+: reading and writing, over-writing or creating
		- a+: reading and writing, appending or creating
	*/

	//TODO: open file to write with "w" mode string

	while ((ch = fgetc(fr)) != EOF)	// getc(fr)
	{
		// ì–´ë–¤ streamì„ ì‚¬ìš©í•  ê²ƒì¸ì§€ë§Œ ë‹¤ë¥´ì§€, ch ë‚´ìš©ì„ stdout streamìœ¼ë¡œ ì¶œë ¥í•˜ëŠ”(=í™”ë©´ìœ¼ë¡œ ì¶œë ¥)
		//putc(ch, stdout);	// same as putchar(ch);
		fputc(ch, stdout);  // ë” ì•ˆì •ì .(?)

		//TODO: use fputs() to write a file stream!

		count++;
	}

	fclose(fr);
	//TODO:

	printf("FILE %s has %lu characters\n", argv[1], count);

	return 0;
}
```
- practice  
  1. Tip : scanf("%19s", file_path2):  
  19ë¡œ ì…ë ¥ í¬ê¸°ë¥¼ ì œí•œí•˜ì—¬, ì‚¬ìš©ìê°€ 20ì ì´ìƒì˜ ë¬¸ìì—´ì„ ì…ë ¥í•˜ì§€ ì•Šë„ë¡.  
  ë‚˜ë¨¸ì§€ í•œ ìë¦¬ëŠ” '\0'ì„ ìœ„í•œ ê³µê°„ -> ë²„í¼ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€  
  2. Tip : scanfë¡œ ì…ë ¥ì„ ë°›ìœ¼ë©´ '\n'ì´ ë²„í¼ì— ë‚¨ì•„ì„œ, while (getchar() != '\n'); ì„ ì‚¬ìš©í•˜ì—¬ ë‚¨ì€ \nì„ ì½ê³  ì²˜ë¦¬.
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

int main()
{
	int pr;
	FILE* file;
	char file_path[20];
	char text[20];
	int ch;

	printf("PATH : ");
	//fgets(file_path, sizeof(file_path), stdin);
	pr = scanf("%19s", file_path);
	if (pr != 1) exit(1);
	while (getchar() != '\n');

	printf("TXT : ");
	fgets(text, sizeof(text), stdin);

	// write
	file = fopen(file_path, "w");
	if (!file) exit(1);

	for (int i = 0; text[i] != '\0'; ++i)
		fputc(text[i], file);

	fclose(file);

	// read
	file = fopen(file_path, "r");
	if (!file) exit(1);

	while ((ch = fgetc(file)) != EOF)
		putchar(ch);

	fclose(file);

	return 0;
}
```


### ğŸ“Œ 13.3 í…ìŠ¤íŠ¸ ì¸ì½”ë”©(incoding)ê³¼ ì½”ë“œ í˜ì´ì§€(code page)
- Windows (CRLF)  
  `CR`: Carriage Return (ìºë¦¬ì§€ ë¦¬í„´) - `\r`  
  `LF`: Line Feed (ë¼ì¸ í”¼ë“œ) - `\n`  
  Windowsì—ì„œëŠ” ì¤„ ë°”ê¿ˆì„ í•  ë•Œ \r\nì„ ì‚¬ìš©í•©ë‹ˆë‹¤.  
  Unix/Linuxì™€ macOSì—ì„œëŠ” \në§Œ ì‚¬ìš©í•©ë‹ˆë‹¤ (LFë§Œ).
- UTF-8, ANSI ... (ì¸ì½”ë”© ë°©ì‹)
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>	// SetConsoleOutputCP()

int main()
{
	const UINT default_cp = GetConsoleOutputCP();
	printf("%u\n", default_cp);

	int ch;
	FILE* fr, * fw;

	const char* in_filename = "ï¿½ï¿½ï¿½ï¿½.txt";
	const char* out_filename = "ï¿½çº».txt";

	unsigned long count = 0;

	if ((fr = fopen(in_filename, "r")) == NULL)	// Open a text file for reading.
	{
		printf("Can't open %s\n", in_filename);
		exit(EXIT_FAILURE);
	}

	if ((fw = fopen(out_filename, "w")) == NULL)	// Open a text file for writing.
	{
		printf("Can't open %s\n", out_filename);
		exit(EXIT_FAILURE);
	}

	SetConsoleOutputCP(CP_UTF8);// UTF-8 mode

	while ((ch = fgetc(fr)) != EOF)
	{
		fputc(ch, stdout);	// same as putchar(ch);
		fputc(ch, fw);
		count++;
	}

	fclose(fr);
	fclose(fw);

	SetConsoleOutputCP(default_cp);// ISO 2022 Korean

	printf("FILE %s has %lu characters\n", in_filename, count);
	printf("Copied to %s\n", out_filename);

	printf("ï¿½Ñ±ï¿½ ï¿½ï¿½ï¿½ È®ï¿½ï¿½");

	return 0;
}
```


### ğŸ“Œ 13.4 í…ìŠ¤íŠ¸ íŒŒì¼ ì…ì¶œë ¥ í•¨ìˆ˜ë“¤ (fprintf(), fscanf(), fgets(), fputs())
<img width="500" alt="image" src="https://github.com/user-attachments/assets/2d70d8be-eee5-416d-a541-0ad010915451" />

<img width="700" alt="image" src="https://github.com/user-attachments/assets/18a196f1-5f14-4dd2-bfea-c9aa60c7236e" />

``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX 31

int main(void)
{
	FILE* fp;
	char words[MAX] = { '\0', };

	const char* filename = "record.txt";

	/*
	fopen() mode strings for text files
	- r: reading
	- w: creating-and-writing or over-writing
	- a: appending or creating-and-writing
	- r+: both reading and writing
	- w+: reading and writing, over-writing or creating
	- a+: reading and writing, appending or creating
	*/

	if ((fp = fopen(filename, "w+")) == NULL)// Try r+, w+, a+
	{
		fprintf(stderr, "Can't open \"%s\" file.\n", filename);
		exit(EXIT_FAILURE);
	}

	//while ((fscanf(stdin, "%30s", words) == 1) && (words[0] != '.'))
	//	fprintf(fp, "%s\n", words);

	while ((fgets(words, MAX, stdin) != NULL) && (words[0] != '.'))
		fputs(words, fp);

	rewind(fp);  /* go back to beginning of file */

	//while (fscanf(fp, "%s", words) != EOF)
	//	fprintf(stdout, "%s\n", words);

	while (fgets(words, MAX, fp) != NULL)// EOF check
		fputs(words, stdout);

	if (fclose(fp) != 0)
		fprintf(stderr, "Error closing file\n");

	return 0;
}
```


### ğŸ“Œ 13.5 ë°”ì´ë„ˆë¦¬ íŒŒì¼ ì…ì¶œë ¥
<img width="700" alt="image" src="https://github.com/user-attachments/assets/356057ab-57d9-4862-8b67-06a13b2b95f3" />

``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

int main()
{
	/*
	fopen() mode string for binary IO
	- "rb", "wb", "ab"
	- "ab+", "a+b"
	- "wb+", "w+b"
	- "ab+", "a+b"

	C11 'x' mode fails if the file exists, instead of overwriting it.
	- "wx", "wbx", "w+x", "wb+x", "w+bx"
	*/

	// Writing example
	{
		FILE* fp = fopen("binary_file", "wb");

		double d = 1.0 / 3.0;
		int n = 123;
		int* parr = (int*)malloc(sizeof(int) * n);
		if (!parr) exit(1);
		for (int n = 0; n < 123; ++n)
			*(parr + n) = n * 2;

		// size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream);
		// (ë°ì´í„°ë¥¼ ì €ì¥í•œ ë©”ëª¨ë¦¬ ë²„í¼ì— ëŒ€í•œ í¬ì¸í„°, í•œ ê°œì˜ í•­ëª©ì´ ì°¨ì§€í•˜ëŠ” í¬ê¸°(ë°”ì´íŠ¸),
		//  size í¬ê¸°ì˜ í•­ëª©ì´ ëª‡ ê°œê°€ ì“°ì¼ì§€ ì§€ì •, ë°ì´í„°ë¥¼ ì“¸ íŒŒì¼ í¬ì¸í„°)
		fwrite(&d, sizeof(d), 1, fp);
		fwrite(&n, sizeof(n), 1, fp);
		fwrite(parr, sizeof(int), n, fp);

		fclose(fp);
		free(parr);

		// Total size is 8 * 1 + 4 * 1 + 123 * 4 = 504 bytes
	}
	// Reading example, feof(), ferror()
	{
		FILE* fp = fopen("binary_file", "rb");
		double d;
		int n = 0;
		fread(&d, sizeof(d), 1, fp);
		fread(&n, sizeof(n), 1, fp);

		int* parr = (int*)malloc(sizeof(int) * n); 
		if (!parr) exit(1);

		fread(parr, sizeof(int), n, fp);

		// ì €ì¥ëœ ê°¯ìˆ˜ë§Œí¼ë§Œ ë¶ˆëŸ¬ì™”ê¸° ë•Œë¬¸ì— EOFë¥¼ ë§Œë‚˜ì§€ ì•Šì•˜ìŒ = 0
		printf("feof = %d\n", feof(fp));

		printf("%f\n", d);
		printf("%d\n", n);
		for (int i = 0; i < n; ++i)
			printf("%d ", *(parr + i));
		printf("\n");

		printf("feof = %d\n", feof(fp));

		fread(&n, sizeof(n), 1, fp);		 // read one more toward EOF

		// EOF ë§Œë‚¬ìŒ = 1
		printf("feof = %d\n", feof(fp));     // returns non-zero at EOF
		printf("ferror = %d\n", ferror(fp)); // returns 0 : ok

		fwrite(&n, sizeof(n), 1, fp);		 // try writing to make an error

		printf("ferror = %d\n", ferror(fp)); // 0 is ok, non-zero otherwise.

		fclose(fp);
		free(parr);
	}

	return 0;
}
```


### ğŸ“Œ 13.6 íŒŒì¼ ì„ì˜ ì ‘ê·¼(Random Access)

<img width="450" alt="image" src="https://github.com/user-attachments/assets/e146e981-b436-4850-8b0b-4daa5fc7ed1c" />
















