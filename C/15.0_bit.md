### ğŸ“Œ 15.1 ë¹„íŠ¸ë‹¨ìœ„ ë…¼ë¦¬ ì—°ì‚°ì (Bitwise Logical Operators)
<img width="400" src="https://github.com/user-attachments/assets/feed9c4a-b487-4337-b960-e17a5b23375f"/>
<img width="300" src="https://github.com/user-attachments/assets/5a5def5e-d81a-405b-9fda-02b743920457"/>
<img width="300" src="https://github.com/user-attachments/assets/7ec933b6-beb6-42da-8308-a7cefeb7ec5d"/>
<img width="300" src="https://github.com/user-attachments/assets/f2c63995-3070-44c9-b5aa-ed46ea2393c9"/>
<img width="300" src="https://github.com/user-attachments/assets/2ba3ff18-6fb5-419a-8274-74ff2f13b822"/>


### ğŸ“Œ 15.2 ì´ì§„ìˆ˜ë¥¼ ì‹­ì§„ìˆ˜ë¡œ ë°”ê¾¸ê¸° ì—°ìŠµë¬¸ì œ
### ğŸ“Œ 15.3 &ë¥¼ ì´ìš©í•´ì„œ ì‹­ì§„ìˆ˜ë¥¼ ì´ì§„ìˆ˜ë¡œ ë°”ê¾¸ê¸° ì—°ìŠµë¬¸ì œ
### ğŸ“Œ 15.4 ë¹„íŠ¸ë‹¨ìœ„ ë…¼ë¦¬ ì—°ì‚°ì í™•ì¸í•´ë³´ê¸°
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <math.h>
#include <string.h>

unsigned char to_decimal(const char bi[]);
void print_binary(const unsigned char num);

int main()
{
	//printf("%d\n", to_decimal("00000110"));
	//printf("%d\n", to_decimal("00010110"));
	//printf("%d\n", to_decimal("10010100"));

	unsigned char i = to_decimal("01000110");
	unsigned char mask = to_decimal("00000101");

	printf("%hhu, %hhu\n", i, mask);	// 70, 5

	print_binary(i);
	print_binary(mask);
	print_binary(i & mask);


		/*
		Regular Logical Operators : &&, ||, and !

		bool have_apple = true;
		bool like_apple = true;
		if (have_apple && like_apple)
			eat_apple();

		Bitwise Logical Operators :
		- Bitwise NOT ~
		- Bitwise AND &
		- Bitwise OR |
		- Bitwise EXCLUSIVE OR ^
		*/

	unsigned char a = 6;
	unsigned char b = 5;

	printf("%hhu\n", a);
	print_binary(a);			// 00000110

	printf("%hhu\n", b);
	print_binary(b);			// 00000101

	printf("%hhu\n", a & b);
	print_binary(a & b);		// 00000100 -> and

	printf("%hhu\n", a | b);
	print_binary(a | b);		// 00000111 -> or

	printf("%hhu\n", a ^ b);
	print_binary(a ^ b);		// 00000011 -> xor

	printf("%hhu\n", ~a);
	print_binary(~a);			// 11111001 -> not(reverse)

	return 0;
}

void print_binary(const unsigned char num)
{
	printf("Decimal\t%d\t== Binary ", num);

	const size_t bits = sizeof(num) * 8;

	for (int i = 0; i < (int)bits; ++i)
	{
		unsigned char mask = (char)pow((double)2, (double)(bits - 1 - i));
		//printf("%hhu\n", mask);

		if ((num & mask) == mask)
			printf("%d", 1);
		else
			printf("%d", 0);
	}
	printf("\n");
}

unsigned char to_decimal(const char bi[])
{
	const size_t size = strlen(bi);
	unsigned char x = 0;

	for (size_t i = 0; i < size; ++i)
	{
		//printf("%d ", x);
		if (bi[i] == '1')
			x += (int)pow(2, size - 1 - i);
		//printf("%d\n", x);
	}

	return x;
}
```


### ğŸ“Œ 15.5 2ì˜ ë³´ìˆ˜ í‘œí˜„ë²• í™•ì¸í•´ë³´ê¸°(2's complement)
<img width="350" src="https://github.com/user-attachments/assets/23ea8d46-c8f9-4153-ba87-2837caff5751"/>

``` c
int main()
{
	/*
	Signed Integers

	- Sign-magnitude representation
	00000001 is 1 and 10000001 is -1
	00000000 is +0, 10000000 is -0
	Two zeros +0 -0, from -127 to +127

	- One's complement method
	To reverse the sign, invert each bit.
	00000001 is 1 and 11111110 is -1.
	11111111 is -0
	from -127 to +127

	- Two's complement method (commonly used in most systems)
	To reverse the sign, invert each bit and add 1.
	from -128 to +127

	*/

	print_binary(127);		//01111111
	print_binary(-127);		//10000001
	print_binary(~127 + 1);	//10000001  <- 127ì— ìŒìˆ˜ë¶€í˜¸ + 1 í•„ìš”.

	print_binary(12);		//00001100
	print_binary(-12);		//11110100
	print_binary(~12 + 1);	//11110100

	print_binary(7);		//00000111
	print_binary(-7);		//11111001
	print_binary(~- 7 + 1);	//00000111

	return 0;
}
```


### ğŸ“Œ 15.6 ë¹„íŠ¸ë‹¨ìœ„ ì‰¬í”„íŠ¸ ì—°ì‚°ì(shift)
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

void int_binary(const int num);

int main()
{
	/*
		Bitwise shift operators

		- Left shift
		number << n : multiply number by 2^n

		- Right shift
		number >> n : divide by 2^n (for non-negative numbers)
	*/

	// 8 bit integer cases
	//							       76543210         76543210       76543210
	printf("%hhd\n", 1 << 3);		// 00000001 ->   00000001???    -> 00001000
	printf("%hhd\n", 8 >> 1);		// 00001000 ->      ?00001000  ->  00000100

	// -14ì¸ë°, -0ì´ ì—†ì–´ì„œ í•œìë¦¬ê°€ ë‹¹ê²¨ì§„ë‹¤.
	printf("%hhd\n", -119 >> 3);	// 10001001 ->      ???10001001 -> 11110001 (-15)
	//printf("%hhd\n", -119 / 8);
	printf("%hhu\n", 137 >> 3);	// 10001001 ->      ???10001001 -> 00010001 (17)
	//printf("%hhu\n", 137 / 8);

	// ìë¦¿ìˆ˜ ë¬¸ì œë¡œ ì›í•˜ëŠ” ê²°ê³¼ê°€ ë‚˜ì˜¤ì§€ ì•ŠìŒ.
	printf("%hhd\n", -119 << 4);	// 10001001 ->  10001001????    -> 10010000 (-112)
	printf("%hhu\n", 137 << 4);	// 10001001 ->  10001001????    -> 10010000 (144)

	//Note: the signed result is machine dependent

	int a = 1;
	a <<= 3;
	a >>= 2;

	printf("Unsigned int %u\n", 0xffffffff);
	printf("Signed int %d\n", 0xffffffff);
	int_binary(0xffffffff);
	printf("Right shift by 3\n");
	int_binary((signed)0xffffffff >> 3);
	int_binary((unsigned)0xffffffff >> 3);

	printf("\nUnsigned int %u\n", 0x00ffffff);
	printf("Signed int %d\n", 0x00ffffff);
	int_binary(0x00ffffff);
	printf("Right shift by 3\n");
	int_binary((signed)0x00ffffff >> 3);
	int_binary((unsigned)0x00ffffff >> 3);

	return 0;
}

void int_binary(const int num)
{
	printf("Decimal %12d == Binary ", num);

	const size_t bits = sizeof(num) * CHAR_BIT;
	for (size_t i = 0; i < bits; ++i)
	{
		const int mask = 1 << (bits - 1 - i);

		if ((num & mask) == mask)
			printf("%d", 1);
		else
			printf("%d", 0);
	}

	printf("\n");
}
```
<img width="350" src="https://github.com/user-attachments/assets/b0064d3d-a69a-4bab-86de-35ee317b0909"/>


### ğŸ“Œ 15.7 ë¹„íŠ¸ë‹¨ìœ„ ì—°ì‚°ìì˜ ë‹¤ì–‘í•œ ì‚¬ìš©ë²•
<img width="350" src="https://github.com/user-attachments/assets/0dfe69d8-effa-431a-b91c-9e7ff034e886"/>

``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <math.h>

//					 Shift       Decimal  Binary    Hex   Octet
#define MASK_SWORD	 (1 << 0) // 2^0      00000001  0x01  01	
#define MASK_SHIELD	 (1 << 1) // 2^1      00000010  0x02  02	
#define MASK_POTION	 (1 << 2) // 2^2      00000100  0x04  04	
#define MASK_GUNTLET (1 << 3) // 2^3      00001000  0x08  010	
#define MASK_HAMMER  (1 << 4) // 2^4      00010000  0x10  020	
#define MASK_KEY	 (1 << 5) // 2^5      00100000  0x20  040	
#define MASK_RING	 (1 << 6) // 2^6      01000000  0x40  0100	
#define MASK_AMULET  (1 << 7) // 2^7      10000000  0x80  0200	

void char_binary(const char num);
void int_binary(const int num);

/*
	flag			01011010
	mask			00000011
	mask & flag ==  00000010
*/

int main()
{
	/*
	bool has_sword  = false;
	bool has_shield = false;
	bool has_potion = false;
	bool has_guntlet = false;
	bool has_hammer = false;
	bool has_key = false;
	bool has_ring = false;
	bool has_amulet = false;
	*/

	char flags = 0;		// MASK flags
	char_binary(flags);

	printf("\nTurning Bits On (Setting Bits)\n");

	flags = flags | MASK_SWORD;//flag |= MASK_SWORD;
	char_binary(flags);
	flags |= MASK_AMULET;
	char_binary(flags);

	printf("\nTurning Bits Off (Clearning Bits)\n");

	flags = flags | MASK_POTION;
	char_binary(flags);
	flags = flags & ~MASK_POTION;// flags &= ~MASK_POTION;
	char_binary(flags);

	printf("\nToggling Bits\n");

	flags = flags ^ MASK_HAMMER;
	char_binary(flags);

	flags = flags ^ MASK_HAMMER;
	char_binary(flags);

	flags = flags ^ MASK_HAMMER;
	char_binary(flags);

	printf("\nChecking the Value of a Bit\n");

	if ((flags & MASK_KEY) == MASK_KEY)
		printf(">> You can enter.\n");
	else
		printf(">> You can not enter.\n");

	flags |= MASK_KEY;// Obtained a key!

	if ((flags & MASK_KEY) == MASK_KEY)
		printf(">> You can enter.\n");
	else
		printf(">> You can not enter.\n");

	printf("\nTrimming\n");

	int int_flag = 0xffffffff;
	// 11111111111111111111111111111111
	int_binary(int_flag);
	int_flag &= 0xff;
	// Trim by 11111111
	int_binary(int_flag);

	return 0;
}

void char_binary(const char num)
{
	printf("Decimal %3d \t== Binary ", num);

	const size_t bits = sizeof(num) * 8;
	for (size_t i = 0; i < bits; ++i)
	{
		const char mask = 1 << (bits - 1 - i);

		if ((num & mask) == mask)
			printf("%d", 1);
		else
			printf("%d", 0);
	}

	printf("\n");
}

void int_binary(const int num)
{
	printf("Decimal %3d \t== Binary ", num);

	const size_t bits = sizeof(num) * 8;
	for (size_t i = 0; i < bits; ++i)
	{
		const int mask = 1 << (bits - 1 - i);

		if ((num & mask) == mask)
			printf("%d", 1);
		else
			printf("%d", 0);
	}

	printf("\n");
}
```


### ğŸ“Œ 15.8 RGBA ìƒ‰ìƒ ë¹„íŠ¸ ë§ˆìŠ¤í¬ ì—°ìŠµë¬¸ì œ
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#define BYTE_MASK 0xff

int main()
{
	unsigned int rgba_color = 0x66CDAAFF;
	// 4 bytes, medium aqua marine	(102, 205, 170, 255)

	unsigned char red, green, blue, alpha;

	//Use right shift >> operator
	alpha = rgba_color & BYTE_MASK;				// alphaëŠ” ìë¦¬ ê·¸ëŒ€ë¡œë‹ˆê¹Œ ë°”ë¡œ and
	blue = (rgba_color >> 8 & BYTE_MASK);		// blueëŠ” 8ë¹„íŠ¸ ë°€ê³  and
	green = (rgba_color >> 16 & BYTE_MASK);		// greenì€ 16ë¹„íŠ¸ ë°€ê³  and
	red = (rgba_color >> 24 & BYTE_MASK);		// redëŠ” 24ë¹„íŠ¸ ë°€ê³  and

	printf("(R, G, B, A) = (%hhu, %hhu, %hhu, %hhu)\n",
		red, green, blue, alpha);

	return 0;
}
```


### ğŸ“Œ 15.9 êµ¬ì¡°ì²´ ì•ˆì˜ ë¹„íŠ¸ í•„ë“œ

























### ğŸ“Œ 



