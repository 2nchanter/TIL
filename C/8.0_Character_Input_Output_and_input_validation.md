### 📌 8.1 입출력 버퍼
- buffer : 버퍼는 입출력을 효율적으로 처리하기 위해 데이터(문자, 숫자 등)를 임시로 저장하는 메모리 공간  
  입출력 장치는 CPU보다 속도가 느려서, 한 글자씩 처리하면 비효율적이므로 한 번에 모아서 처리하는 방식이 일반적  
  <img width="400" alt="image" src="https://github.com/user-attachments/assets/9b6377af-b442-49f1-abc6-731bf0698d70" />
``` c
#include <stdio.h>
#include <conio.h>
int main()
{
	char c;

	// buffer !
	while ((c = getchar()) != '.')
		putchar(c);

	// no buffer !
	while ((c = _getche()) != '.')  // e : echo
		putchar(c);

	while ((c = _getch()) != '.')
		putchar(c);

	return 0;
}
```
- 보충 설명
``` c
#include <stdio.h>

int main() {
    char c;
    
    while ((c = getchar()) != '\n') {  // 입력 버퍼에서 한 글자 가져오기
        putchar(c);  // 출력 버퍼로 보내서 화면에 출력
    }

    return 0;
}
```
- 키보드에서 입력하면 버퍼에 먼저 저장되고, Enter(개행 문자 '\n')을 눌러야 프로그램이 입력을 읽음.  
  getchar()는 버퍼에서 한 글자씩 꺼내오는 함수이므로 while문을 돌 때마다 버퍼에서 가져오는 것.  
  putchar()도 출력 버퍼에 저장한 후 한꺼번에 출력하는 방식이라 개행 문자('\n')가 있을 때 즉시 출력됨.  
  <img width="400" alt="image" src="https://github.com/user-attachments/assets/7f7aca42-901d-42cf-aa08-96bd9ca485e3" />


### 📌 8.2 파일의 끝 (End of File, EOF)
- stream이 언제 끝나는지를 EOF로 판단.
- ctrl+z를 버퍼에 넣어서 전송하면 EOF이 된다.
- ctrl + c는 강제종료.
``` c
#include <stdio.h>

int main()
{
	int c;

	//while ((c = getchar()) != EOF)
	//	putchar(c);

	// stream
	while (1)
	{
		c = getchar();
		printf("%d\n", c);
		if (c == EOF)
			break;
	}

	return 0;
}
```


### 📌 8.3 입출력 방향 재지정(redirection)
- 데이터의 흐름을 조정, 재지정 할 수 있다.  
  cmd에서 output 확인하기 : `TBC.exe`  
  cmd에서 output을 .txt로 저장(redirection) 하기 : TBC.exe `> output.txt`  
  cmd에서 직접 input/output 하기 : TBC.exe (with scanf)  
  cmd에서 .txt로 input/output : TBC.exe `< input.txt`  
  (TBC.exe > output.txt < input.txt 도 가능)  
  cmd에서 output을 .txt로 이어서 저장하기 : TBC.exe `>> output.txt`  
  복사 : copy TBC.exe test.exe  
  데이터 스트림(파이프) test : `test.exe | TBC.exe`  
``` c
#include <stdio.h>

int main()
{
	// test.exe
	printf("Programming");

	// TBC.exe
	char str[100];
	scanf("%s", str);
	printf("I love %s.\n", str);  // result : I love Programming

	return 0;
}
```


### 📌 8.4 사용자 인터페이스는 친절하게
``` c
#include <stdio.h>

int main()
{
	int count = 0;

	while (1)
	{
		printf("Current count is %d. Continue? (y/n)\n", count);

		int c = getchar();

		if (c == 'n')
			break;
		else if (c == 'y')
			count++;
		else
			printf("Please input y or n\n");

		while (getchar() != '\n')
			continue;
	}

	return 0;
}
```


### 📌 8.5 숫자와 문자를 섞어서 입력받기
- getchar()를 사용하여 첫 번째 문자만 읽고, scanf("%d %d")로 숫자를 읽는 구조.  
  ⚠️ scanf는 공백을 무시하는 특성이 있기 때문에, 3 앞에 있는 공백은 무시되고, 4 앞의 공백은 문법적으로 필요한 공백
``` c
#include <stdio.h>

void display(char cr, int lines, int width);

int main()
{
	char c;
	int rows, cols;

	//// 1
	//while (1)
	//{
	//	scanf("%c %d %d", &c, &rows, &cols);
	//	while (getchar() != '\n')
	//		continue;
	//	display(c, rows, cols);
	//	if (c == '\n')  // <<< problem !!!
	//		break;
	//}

	// 2
	printf("Input one character and two integers:\n");

	while ((c = getchar()) != '\n')
	{
		scanf("%d %d", &rows, &cols);
		while (getchar() != '\n')
			continue;
		display(c, rows, cols);
		printf("Input another character and two integers:\n");
		printf("Press Enter to quit.\n");
	}

	return 0;
}

void display(char cr, int lines, int width)
{
	for (int i = 1; i <= lines; ++i)
	{ 
		for (int l = 1; l <= width; ++l)
		{
			//printf("%c", cr);
			putchar(cr);
		}			
		//printf("\n");
		putchar('\n');
	}

}
```


### 📌 8.6 












