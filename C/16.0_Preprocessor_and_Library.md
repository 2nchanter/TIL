### ğŸ“Œ 16.1 ì „ì²˜ë¦¬ê¸°ê°€ í•´ì£¼ëŠ” ì¼ë“¤(Pre-processor)
- Pre-process + compile + linker = Build  
  (compile ì „, ì „ì²˜ë¦¬ê¸°.) : codeì™€ compilerë¥¼ ì—°ê²°í•´ì¤€ë‹¤.
  - ì»´íŒŒì¼ëŸ¬ê°€ ì´í•´í•  ìˆ˜ ìˆë„ë¡ ë²ˆì—­.  
    í”„ë¡œê·¸ë˜ë¨¸ì˜ íš¨ìœ¨ì„ ë†’ì—¬ì£¼ëŠ” ê¸°ëŠ¥ë“¤.  
    ì½”ë“œë¥¼ ë‹¤ì–‘í•˜ê²Œ ì»´íŒŒì¼.(multi platform)  


### ğŸ“Œ 16.2 ì „ì²˜ë¦¬ë¥¼ ì¤€ë¹„í•˜ëŠ” ë²ˆì—­ ë‹¨ê³„(Translate Phases)
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main()
{
	/*
		Program written in C

		Translating
		Preprocessing
		Compiling
		Linking

		Executable
	*/

	/*
		International characters
	*/

	puts("ï¿½È³ï¿½ï¿½Ï¼ï¿½ï¿½ï¿½? ï¿½Ñ±ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½Õ´Ï´ï¿½.\n");

	/*
		Trigraph Sequences
		- Some keyboards don't provide all the symbols used in C.
		- Three-character sequences

		Trigraph		Replacement
		??=				#
		??/				\
		??'				^
		??(				[
		??)				]
		??!				|
		??<				{
		??>				}
		??-				~

		/Zc:trigraphs
	*/

	int arr[3] = { 1, 2, 3 };
	//printf("arr??(0??) == %d\n", arr??(0??));
	printf("arr[0] == %d\n", arr[0]);

	/*
		Digraphs
		- Two-character sequences

		Digraph			Equivalent
		<:				[
		:>				]
		<%				{
		%>				}
		%:				#
	*/

	printf("arr<:1:> == %d\n", arr<:1:>);
	//printf("arr[1] == %d\n", arr[1]);

	/* Two physical lines vs One logical line */
	printf("This is a very very very very very\
very very very long long long long long long line.\n");
	
	/*
		Tokens
		- Groups separated from each other by spaces, tabs, or line breaks
		Whitespace characters -> a single space
	*/

	int/*a variable to count a number*/n = 1;
	//int n1 = 1;

	return 0;
}
```


### ğŸ“Œ 16.3 #define ë§¤í¬ë¡œ
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/*
	Preprocessor directives begins with # symbol at the beginning of a line.
*/

/*
	Macro
	- An instruction that represents a sequence of instructions in abbreviated form.
*/

/*
#define			SAY_HELLO		printf("Hello, World!");

Preprocessor	Macro (name)	body (or replacement list)
directive

Macro expansion
*/


/*
	Object-like macros vs Function-like macros

#define ONE 1
#define SQUARE(X) X*X
*/

#define PI 3.141592		/* Symbolic, or manifest, constants */
#define GRAVITY 9.8

#define THREE 3			
#define MESSAGE "The greatest glory in living lies not in never falling, \
but in rising every time we fall."

#define NINE	THREE*THREE
#define	SAY_HELLO for(int i = 0; i <10; i ++) printf("Hello, World!\n");
#define FORMAT "Number is %d.\n"

# define WITH_BLANK 1

#define MY_CH 'Z'
#define MY_ST "Z"	// Z\0

#define LIMIT 20
const int LIM = 50;
static int arr1[LIMIT];
//static int arr2[LIM];		// clang, C++
const int LIM2 = 2 * LIMIT;
//const int LIM3 = 2 * LIM;	// clang, C++

/*
	Tokens

#define SIX 3*2
#define SIX 3 * 2
#define SIX 3		*		2
*/

/* Redefining Constants */
#define SIX 2*3
#define SIX 2*3
#undef SIX
#define SIX 2 * 3	// Warning

int main()
{
	int n = THREE;

	SAY_HELLO		//Note the additional ;  
		n = NINE;

	printf(FORMAT, n);
	printf("%s\n", MESSAGE);	// replaced
	printf("SAY_HELLO NINE\n");	// Not replaced

	return 0;
}
```


### ğŸ“Œ 16.4 í•¨ìˆ˜ ê°™ì€ ë§¤í¬ë¡œ
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/*
	Function-like macros

	#define		ADD(X,Y)	((X)+(Y))

	X and Y : macro arguments
*/

#define	ADD1(X,Y)		X+Y
#define	ADD2(X,Y)		((X)+(Y))
#define SQUARE(X)		X*X			// ((X)*(X))

int main()
{
	int sqr = SQUARE(3);

	int a = 1;

	printf("%d\n", 2 * ADD1(1, 3)); //2 * X + Y = 2 * 1 + 3 = 5 // WRONG!!!
	printf("%d\n", 2 * ADD2(1, 3)); //2 * (1 + 3) = 8

	printf("%d\n", SQUARE(1 + 2)); // 1+2*1+2 = 1 + 2 + 2 = 5 // WRONG!!!!
	printf("%d\n", 100 / SQUARE(3 + 1)); //100 / 3 + 1 * 3 + 1 = 33 + 3 + 1 = 37 // WRONG!!!
	printf("%d\n", SQUARE(++a)); // ++a * ++a = 3 * 3 = 9 // DANGEROUS!

	return 0;
}

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/*
	stringizing operator #
	- converts macro parameters to string literals
*/
#define SQUARE(X)	 (X)*(X)
#define PRINT_SQR1(x) printf("The square of %d is %d.\n", x, SQUARE(x))
#define PRINT_SQR2(x) printf("The square of " #x " is %d.\n", SQUARE(x))

/*
	## operator combines two tokens into a single token
*/

#define XNAME(n)	x ## n
#define PRT_XN(n)   printf("x" #n " = %d\n", x ## n);

int main()
{
	PRINT_SQR1(10);
	PRINT_SQR2(10);

	printf("\n");

	int XNAME(1) = 1;	// int x1 = 1;
	int XNAME(2) = 2;	// int x2 = 2;

	PRT_XN(1);			// printf("x1 " = %d\n", x1);
	PRT_XN(2);			// printf("x2 " = %d\n", x2);

	return 0;
}


/*
	Macro or Function ?
	- no space in the macro name
	- Use parentheses
	- Use capital letters for macro function names
	- Speed up?
*/

#define MAX(X,Y)		((X) > (Y) ? (X) : (Y))
#define MIN(X,Y)		((X) < (Y) ? (X) : (Y))
#define ABS(X,Y)		((X) < 0 ? -(X):(X))
```


### ğŸ“Œ 16.5 ê°€ë³€ ì¸ìˆ˜ ë§¤í¬ë¡œ
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <math.h>

/*
	Variadic Macros	accept a variable number of arguments.
*/

#define PRINT(X, ...) printf("Message " #X ": " __VA_ARGS__) 
// ... : ellipses
// __VA_ARGS : one of the predefined macros

/*
printf(...)
stdvar.h Variadic arguments
*/

int main()
{
	double x = 48;
	double y;

	y = sqrt(x);
	PRINT(1, "x = %g\n", x); 
	printf("Message " "1" ": " "x = %g\n", x);

	PRINT(2, "x = %.2f, y = %.4f\n", x, y);
	printf("Message " "2" ": " "x = %.2f, y = %.4f\n", x, y);

	return 0;
}
```


### ğŸ“Œ 16.6 #includeì™€ í—¤ë” íŒŒì¼
<img width="600" src="https://github.com/user-attachments/assets/d3e7154d-95fb-4625-9967-5b27ffbb60ca"/>
<img width="600" src="https://github.com/user-attachments/assets/4fb11d97-2862-439d-915d-87fcdd6c7a55"/>
<img width="600" src="https://github.com/user-attachments/assets/693d0d1b-0dd6-4b31-a613-c36a848c00ec"/>
<img width="600" src="https://github.com/user-attachments/assets/b20d2ee2-63ac-44d7-afab-6bce4aa91b72"/>
<img width="600" src="https://github.com/user-attachments/assets/f7dba9b4-11f6-44ac-8402-fb0cecef2cb5"/>


### ğŸ“Œ 16.7 ì¡°ê±´ì— ë”°ë¼ ë‹¤ë¥´ê²Œ ì»´íŒŒì¼í•˜ê¸°(Conditional Compilation)
<img width="150" src="https://github.com/user-attachments/assets/f5126994-3075-4e3c-99c6-c4484c871234"/>


### ğŸ“Œ 16.8 ë¯¸ë¦¬ ì •ì˜ëœ ë§¤í¬ë¡œë“¤, #line, #error
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

#include "DifferentFile.h"

void different_function();

int main()
{
	printf("__FILE__ : %s\n", __FILE__);
	printf("__DATE__ %s\n", __DATE__);
	printf("__TIME__ %s\n", __TIME__);
	printf("__LINE__ %d\n", __LINE__);
	printf("__func__ %s\n", __func__);

	different_function();

	different_func_in_different_file();

	/* Not defined in VS */ 

	//printf("__STDC__ %d\n", __STDC__);	// comforms to the C standard
	//printf("__STDC_HOSTED__ %d\n", __STDC_HOSTED__); // hosted vs freestanding implementation KNK p.330
	//printf("__STDC_VERSION__ %ld\n", __STDC_VERSION__);

#line 7
	printf("__LINE__ after #line %d\n", __LINE__);

#line 1 "hello.txt"
	printf("__LINE__ after #line %d\n", __LINE__);
	printf("__FILE__ : %s\n", __FILE__);

#if __LINE__ != 33
#error Not line 33
#endif

#if defined(_WIN64) != 1
#error Not WIN64 platform
#endif

#if __STDC_VERSION__ != 201112L
#error Not C11
#endif

	return 0;
}

void different_function()
{
	printf("This function is %s\n", __func__);
	printf("This is line %d\n", __LINE__);
}
```


### ğŸ“Œ 16.9 #pragma ì§€ì‹œì
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

// https://docs.microsoft.com/en-us/cpp/preprocessor/pragma-directives-and-the-pragma-keyword?view=vs-2019

/*
#pragma tokens (ex: once)
*/

//#pragma pack(1)
//_Pragma("pack(1)") // destringizing : remove first and last ", \" -> "
//#define PACK1 _Pragma("pack(1)")
//PACK1

//#pragma warning( disable : 4477 )
//#pragma warning( error : 4477 )

struct s {
	int i;
	char ch;
	double d;
};

int main()
{
	struct s A;
	printf("Size of A is: %zd", sizeof(A));

	return 0;
}
```


### ğŸ“Œ 16.10 _Generic í‘œí˜„ì‹
``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/*
	Generic selection expression
	- generic programming : code is not specific to a particular type

	_Generic : C11 keyword
*/

#define MYTYPE(X) _Generic((X), \
	int: "int", \
	float : "float", \
	double : "double", \
	default: "other"\
)

int main()
{
	int d = 5;
	
	//printf("%s\n", MYTYPE(d));
	//printf("%s\n", MYTYPE(2.0*d));
	//printf("%s\n", MYTYPE(3L));
	//printf("%s\n", MYTYPE(&d));

	return 0;
}
```


### ğŸ“Œ 16.11 inline í•¨ìˆ˜
<img width="600" src="https://github.com/user-attachments/assets/1a52e2b1-25bc-4bbd-a7b9-69d00bd09a49"/>
<img width="600" src="https://github.com/user-attachments/assets/f82c97b8-26dc-415a-8668-e1e34e086284"/>

<img width="386" alt="image" src="https://github.com/user-attachments/assets/b30fcf10-a48b-413b-ac94-75642c2c1d74" />
<img width="355" alt="image" src="https://github.com/user-attachments/assets/731a9dd3-ea44-45b8-8760-3e084eacb72a" />

``` c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

/*
	Function call has overhead
	- set up the call, pass arguments, jump to the function code, and return.

	inline function specifier
	- Suggests inline replacements.

	Inline functions should be short.
	A function with internal linkage can be made inline. (GCC, clang)
	You can't take its address.
*/

inline int foo()
{
	return 5;
}

// Driver code 
int main()
{
	int ret;

	// inline function call 
	ret = foo();

	printf("Output is: %d\n", ret);
	return 0;
}
```
<img width="500" alt="image" src="https://github.com/user-attachments/assets/358d7794-d754-47bc-add1-977094c4d2f6" />
<img width="600" alt="image" src="https://github.com/user-attachments/assets/848a5480-7b66-4563-844f-97a311175511" />


### ğŸ“Œ 16.12 ë¼ì´ë¸ŒëŸ¬ë¦¬























### ğŸ“Œ 
